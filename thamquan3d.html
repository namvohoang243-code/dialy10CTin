<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√¥ Ph·ªèng 3D - H·ªá Qu·∫£ ƒê·ªãa L√Ω C√°c Chuy·ªÉn ƒê·ªông C·ªßa Tr√°i ƒê·∫•t</title>

    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="style.css">

    <!-- Three.js r128 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls r128 from jsDelivr -->
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>

    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #fff;
            overflow-x: hidden;
        }

        /* Hero Section */
        .hero-3d {
            padding: 120px 0 60px;
            text-align: center;
            background: linear-gradient(135deg, rgba(64, 156, 255, 0.1) 0%, rgba(20, 20, 20, 0.8) 100%);
        }

        .hero-3d h1 {
            font-family: 'Poppins', sans-serif;
            font-size: 3.5rem;
            font-weight: 800;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #ffffff, #409cff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero-3d p {
            font-size: 1.2rem;
            color: #ccc;
            max-width: 700px;
            margin: 0 auto 2rem;
        }

        /* Current Scene Title */
        .current-scene {
            text-align: center;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(64, 156, 255, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(64, 156, 255, 0.3);
        }

        .current-scene h3 {
            color: #409cff;
            font-family: 'Poppins', sans-serif;
            font-size: 1.8rem;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }

        .current-scene h3 i {
            font-size: 1.5rem;
        }

        /* 3D Viewer Container */
        .viewer-container {
            padding: 4rem 0;
        }

        .viewer-wrapper {
            position: relative;
            width: 100%;
            max-width: 1280px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        .polycam-embed {
            width: 100%;
            height: 720px;
            max-height: 720px;
            min-height: 400px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(64, 156, 255, 0.2);
            transition: border-color 0.3s ease;
        }

        .polycam-embed:hover {
            border-color: rgba(64, 156, 255, 0.5);
        }

        /* Scene Selector - 7 C·∫£nh (3 c·ªôt) */
        .scene-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-top: 2rem;
            padding: 0 1rem;
            max-width: 1600px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Video Section - H·ªá Qu·∫£ Di Chuy·ªÉn M·∫£ng Ki·∫øn T·∫°o (matches scene-selector exactly for uniformity) */
        #video-section {
            padding: 4rem 0;
            background: linear-gradient(135deg, rgba(64, 156, 255, 0.05) 0%, rgba(26, 26, 26, 0.8) 100%);
        }

        .video-section-title {
            text-align: center;
            color: #409cff;
            font-family: 'Poppins', sans-serif;
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }

        .video-cards-wrapper {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 1.5rem;
            padding: 0 1rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .video-card {
            background: rgba(64, 156, 255, 0.1);
            border: 2px solid #409cff;
            color: #409cff;
            padding: 1.5rem 1.75rem;
            border-radius: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 1.5rem;
            text-align: left;
            position: relative;
            overflow: hidden;
            min-height: 110px;
            width: 100%;
        }

        .video-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(64, 156, 255, 0.2) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .video-card-icon {
            font-size: 2.8rem;
            width: 70px;
            height: 70px;
            border-radius: 16px;
            background: rgba(64, 156, 255, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .video-card-title {
            font-size: 1.2rem;
            font-weight: 700;
        }

        .video-card-desc {
            font-size: 0.9rem;
            opacity: 0.8;
            font-weight: 400;
        }

        .video-card-text {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .video-card:hover {
            background: rgba(64, 156, 255, 0.2);
            transform: translateY(-6px);
            box-shadow: 0 10px 30px rgba(64, 156, 255, 0.3);
            border-color: #ffffff;
        }

        .video-card:hover::before {
            opacity: 1;
        }

        .video-card:hover .video-card-icon {
            transform: scale(1.1);
        }

        /* Video Modal - Professional design matching page theme */
        .video-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-out;
        }

        .video-modal-overlay.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .video-modal-content {
            position: relative;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            border: 2px solid #409cff;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), 0 0 40px rgba(64, 156, 255, 0.3);
            animation: slideUp 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            width: 95vw;
            height: 95vh;
            max-width: 1400px;
            max-height: 90vh;
        }

        @keyframes slideUp {
            from { transform: translateY(40px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .video-player-container {
            width: 100%;
            height: 85%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-player-container video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .video-modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 44px;
            height: 44px;
            background: rgba(64, 156, 255, 0.2);
            border: 2px solid #409cff;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #409cff;
            font-size: 24px;
            font-weight: 300;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .video-modal-close:hover {
            background: rgba(64, 156, 255, 0.4);
            transform: rotate(90deg) scale(1.1);
        }

        .video-modal-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 11;
            background: rgba(26, 26, 26, 0.95);
            padding: 12px 20px;
            border-radius: 25px;
            border: 2px solid rgba(64, 156, 255, 0.4);
            backdrop-filter: blur(12px);
        }

        .video-control-btn {
            width: 48px;
            height: 48px;
            background: rgba(64, 156, 255, 0.2);
            border: 2px solid #409cff;
            border-radius: 12px;
            cursor: pointer;
            color: #409cff;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .video-control-btn:hover {
            background: rgba(64, 156, 255, 0.4);
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(64, 156, 255, 0.4);
        }

        /* Responsive for Video Section (matches scene-selector) */
        @media (max-width: 768px) {
            .video-cards-wrapper {
                grid-template-columns: 1fr;
                gap: 1rem;
                padding: 0 0.5rem;
            }

            .video-card {
                padding: 1.2rem 1.4rem;
                min-height: 90px;
                gap: 1rem;
            }

            .video-card-icon {
                font-size: 2.2rem;
                width: 60px;
                height: 60px;
            }

            .video-card-title {
                font-size: 1rem;
            }

            .video-card-desc {
                font-size: 0.85rem;
            }

            .video-section-title {
                font-size: 1.8rem;
            }

            .video-modal-content {
                width: 98vw;
                height: 92vh;
                border-radius: 15px;
            }
        }

        .scene-btn {
            background: rgba(64, 156, 255, 0.1);
            border: 2px solid #409cff;
            color: #409cff;
            padding: 1.5rem 1.5rem;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            text-align: center;
        }

        .scene-btn i {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        .scene-btn .scene-name {
            font-size: 1.2rem;
            font-weight: 700;
        }

        .scene-btn .scene-desc {
            font-size: 0.9rem;
            opacity: 0.8;
            font-weight: 400;
        }

        .scene-btn:hover {
            background: rgba(64, 156, 255, 0.2);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(64, 156, 255, 0.3);
            border-color: #ffffff;
        }

        .scene-btn.active {
            background: linear-gradient(135deg, #409cff, #67d7ff);
            color: #1a1a1a;
            border-color: #ffffff;
            transform: scale(1.05);
            box-shadow: 0 15px 40px rgba(64, 156, 255, 0.5);
        }

        .scene-btn.active i,
        .scene-btn.active .scene-name,
        .scene-btn.active .scene-desc {
            color: #1a1a1a;
        }

        /* Instructions */
        .instructions {
            background: rgba(64, 156, 255, 0.05);
            border: 1px solid rgba(64, 156, 255, 0.2);
            border-radius: 15px;
            padding: 2rem;
            margin-top: 3rem;
            text-align: center;
        }

        .instructions h3 {
            color: #409cff;
            margin-bottom: 1.5rem;
            font-family: 'Poppins', sans-serif;
        }

        .instruction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .instruction-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            background: rgba(20, 20, 20, 0.3);
            border-radius: 10px;
        }

        .instruction-item i {
            font-size: 2rem;
            color: #409cff;
        }

        .instruction-item p {
            color: #ccc;
            margin: 0;
        }

        /* Back Button */
        .back-btn {
            position: fixed;
            top: 90px;
            left: 20px;
            z-index: 1000;
            background: rgba(64, 156, 255, 0.9);
            color: #1a1a1a;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 50px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(64, 156, 255, 0.3);
        }

        .back-btn:hover {
            background: #409cff;
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(64, 156, 255, 0.4);
        }

        /* Loading Animation */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(20, 20, 20, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 20px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .loading-overlay.show {
            opacity: 1;
            pointer-events: all;
        }

        .spinner {
            border: 4px solid rgba(64, 156, 255, 0.1);
            border-left-color: #409cff;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        .loading-text {
            color: #409cff;
            font-size: 1.1rem;
            font-weight: 600;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Ph·∫ßn m·ªõi: M√¥ t·∫£ chuy·ªÉn ƒë·ªông c·ªßa c√°c h√†nh tinh kh√°c */
        .planet-description {
            padding: 4rem 0;
            background: linear-gradient(135deg, rgba(64, 156, 255, 0.05) 0%, rgba(20, 20, 20, 0.8) 100%);
        }

        .planet-description .container {
            max-width: 1200px;
        }

        .planet-description h2 {
            color: #409cff;
            text-align: center;
            margin-bottom: 2rem;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .planet-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
        }

        .planet-card {
            background: rgba(20, 20, 20, 0.8);
            border: 1px solid rgba(64, 156, 255, 0.3);
            border-radius: 15px;
            padding: 1.5rem;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .planet-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(64, 156, 255, 0.2);
            border-color: #409cff;
        }

        .planet-card h3 {
            color: #67d7ff;
            font-size: 1.4rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .planet-card p {
            color: #ddd;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .planet-card ul {
            list-style-type: none;
            padding-left: 0;
            margin-top: 1rem;
        }

        .planet-card li {
            margin-bottom: 0.5rem;
            position: relative;
            padding-left: 1.5rem;
        }

        .planet-card li::before {
            content: '\f0da';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            position: absolute;
            left: 0;
            color: #409cff;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .hero-3d h1 {
                font-size: 2.5rem;
            }

            .polycam-embed {
                height: 400px;
                min-height: 280px;
            }

            .back-btn {
                top: 80px;
                left: 10px;
                padding: 0.6rem 1.2rem;
                font-size: 0.9rem;
            }

            .scene-selector {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .scene-btn {
                padding: 1.2rem;
            }

            .scene-btn i {
                font-size: 2rem;
            }

            .scene-btn .scene-name {
                font-size: 1rem;
            }

            .scene-btn .scene-desc {
                font-size: 0.8rem;
            }

            .current-scene h3 {
                font-size: 1.3rem;
            }

            .planet-description h2 {
                font-size: 2rem;
            }

            .planet-grid {
                grid-template-columns: 1fr;
            }

            .time-scale-info {
                padding: 1rem;
            }

            .time-scale-info h4 {
                font-size: 1.1rem;
            }

            .time-scale-grid {
                grid-template-columns: 1fr;
            }

            .time-scale-item .value {
                font-size: 1rem;
            }
        }

        /* Globe Container Styles */
        #globe-container {
            width: 100%;
            height: 720px;
            max-height: 720px;
            min-height: 400px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(64, 156, 255, 0.2);
            transition: border-color 0.3s ease;
            display: none; /* Hidden by default */
            background: radial-gradient(circle at center, #000428 0%, #000000 100%);
        }

        #globe-container:hover {
            border-color: rgba(64, 156, 255, 0.5);
        }

        /* Day Night Container */
        #daynight-3d-container {
            width: 100%;
            height: 720px;
            max-height: 720px;
            min-height: 400px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(64, 156, 255, 0.2);
            transition: border-color 0.3s ease;
            display: none;
            background: radial-gradient(circle at center, #000428 0%, #000000 100%);
            position: relative;
            overflow: hidden;
        }

        #daynight-3d-container:hover {
            border-color: rgba(64, 156, 255, 0.5);
        }

        #daynight-3d-container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        /* Seasons 3D Container */
        #seasons-3d-container {
            width: 100%;
            height: 720px;
            max-height: 720px;
            min-height: 400px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(64, 156, 255, 0.2);
            transition: border-color 0.3s ease;
            display: none;
            background: radial-gradient(circle at center, #001020 0%, #000000 100%);
            position: relative;
            overflow: hidden;
        }

        #seasons-3d-container:hover {
            border-color: rgba(64, 156, 255, 0.5);
        }

        #seasons-3d-container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        /* Earth Structure 3D Container */
        #structure-3d-container {
            width: 100%;
            height: 720px;
            max-height: 720px;
            min-height: 400px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(64, 156, 255, 0.2);
            transition: border-color 0.3s ease;
            display: none;
            background: radial-gradient(circle at center, #000510 0%, #000000 100%);
            position: relative;
            overflow: hidden;
        }

        #structure-3d-container:hover {
            border-color: rgba(64, 156, 255, 0.5);
        }

        #structure-3d-container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        /* Plate Tectonics 3D Container */
        #plate-tectonics-container {
            width: 100%;
            height: 720px;
            max-height: 720px;
            min-height: 400px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(64, 156, 255, 0.2);
            transition: border-color 0.3s ease;
            display: none;
            background: radial-gradient(circle at center, #001510 0%, #000000 100%);
            position: relative;
            overflow: hidden;
        }

        #plate-tectonics-container:hover {
            border-color: rgba(64, 156, 255, 0.5);
        }

        #plate-tectonics-container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        /* Season Control Panel */
        .season-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 1rem;
            background: rgba(20, 20, 20, 0.9);
            padding: 1rem 2rem;
            border-radius: 50px;
            border: 2px solid rgba(64, 156, 255, 0.4);
            backdrop-filter: blur(10px);
        }

        .season-btn-control {
            background: rgba(64, 156, 255, 0.2);
            border: 2px solid #409cff;
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .season-btn-control:hover {
            background: rgba(64, 156, 255, 0.4);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(64, 156, 255, 0.3);
        }

        .season-btn-control.active {
            background: linear-gradient(135deg, #409cff, #67d7ff);
            color: #1a1a1a;
            border-color: #ffffff;
            transform: scale(1.05);
        }

        /* Earth Structure Control Buttons */
        .structure-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 1rem;
            background: rgba(20, 20, 20, 0.9);
            padding: 1rem 2rem;
            border-radius: 50px;
            border: 2px solid rgba(64, 156, 255, 0.4);
            backdrop-filter: blur(10px);
        }

        .structure-control-btn {
            background: rgba(64, 156, 255, 0.2);
            border: 2px solid #409cff;
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .structure-control-btn:hover {
            background: rgba(64, 156, 255, 0.4);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(64, 156, 255, 0.3);
        }

        .structure-control-btn.active {
            background: linear-gradient(135deg, #ff9800, #f57c00);
            border-color: #ff9800;
            transform: scale(1.05);
        }

        /* Structure Info Panel - Center */
        .structure-info-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            max-height: 75vh;
            background: rgba(10, 15, 35, 0.95);
            border: 2px solid rgba(79, 195, 247, 0.4);
            border-radius: 20px;
            padding: 2rem;
            z-index: 5;
            overflow-y: auto;
            backdrop-filter: blur(15px);
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            animation: fadeInScale 0.5s ease;
            pointer-events: auto;
        }

        #structure-3d-container canvas {
            pointer-events: auto;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .structure-info-panel::-webkit-scrollbar {
            width: 8px;
        }

        .structure-info-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .structure-info-panel::-webkit-scrollbar-thumb {
            background: rgba(79, 195, 247, 0.5);
            border-radius: 10px;
        }

        .structure-info-header {
            text-align: center;
            margin-bottom: 2rem;
            border-bottom: 2px solid rgba(79, 195, 247, 0.3);
            padding-bottom: 1rem;
        }

        .structure-info-header h2 {
            color: #4fc3f7;
            font-size: 2rem;
            margin: 0 0 0.5rem 0;
            text-shadow: 0 0 20px rgba(79, 195, 247, 0.6);
        }

        .structure-info-header .subtitle {
            color: #90caf9;
            font-size: 1rem;
            margin: 0;
            opacity: 0.9;
        }

        .structure-info-content {
            color: #e0e0e0;
        }

        .info-section {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border-left: 4px solid #4fc3f7;
        }

        .info-section h3 {
            color: #4fc3f7;
            font-size: 1.3rem;
            margin: 0 0 1rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-section p {
            margin: 0.5rem 0;
            line-height: 1.6;
            font-size: 0.95rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .stat-item {
            background: rgba(79, 195, 247, 0.1);
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(79, 195, 247, 0.3);
        }

        .stat-label {
            display: block;
            color: #90caf9;
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }

        .stat-value {
            display: block;
            color: #fff;
            font-size: 1.1rem;
            font-weight: bold;
        }

        .layer-detail {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .layer-detail:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(5px);
        }

        .layer-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            color: #000;
            flex-shrink: 0;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .layer-text h4 {
            color: #ffd54f;
            margin: 0 0 0.5rem 0;
            font-size: 1.1rem;
        }

        .layer-text p {
            margin: 0.3rem 0;
            color: #e0e0e0;
            font-size: 0.9rem;
        }

        .layer-text strong {
            color: #4fc3f7;
        }

        .fun-facts {
            list-style: none;
            padding: 0;
            margin: 1rem 0 0 0;
        }

        .fun-facts li {
            padding: 0.8rem 1rem;
            margin-bottom: 0.8rem;
            background: rgba(255, 193, 7, 0.1);
            border-left: 4px solid #ffc107;
            border-radius: 8px;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .fun-facts li:hover {
            background: rgba(255, 193, 7, 0.2);
            transform: translateX(5px);
        }

        /* Responsive cho Structure Info Panel */
        @media (max-width: 768px) {
            .structure-info-panel {
                width: 95%;
                max-height: 80vh;
                padding: 1.5rem;
            }

            .structure-info-header h2 {
                font-size: 1.5rem;
            }

            .stats {
                grid-template-columns: 1fr;
            }

            .layer-detail {
                flex-direction: column;
            }

            .layer-icon {
                width: 35px;
                height: 35px;
                font-size: 1rem;
            }
        }

        /* Time Scale Info Box */
        .time-scale-info {
            background: rgba(20, 20, 20, 0.9);
            border: 2px solid rgba(64, 156, 255, 0.4);
            border-radius: 15px;
            padding: 1.5rem;
            margin-top: 2rem;
            backdrop-filter: blur(10px);
        }

        .time-scale-info h4 {
            color: #409cff;
            font-size: 1.3rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .time-scale-info h4 i {
            font-size: 1.2rem;
        }

        .time-scale-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }

        .time-scale-item {
            background: rgba(64, 156, 255, 0.08);
            padding: 1rem;
            border-radius: 10px;
            border-left: 3px solid #409cff;
        }

        .time-scale-item .label {
            color: #67d7ff;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .time-scale-item .value {
            color: #ffffff;
            font-size: 1.1rem;
            font-weight: 700;
        }

        .time-scale-item .real-time {
            color: #aaa;
            font-size: 0.85rem;
            margin-top: 0.3rem;
        }

        /* Time Zone Information Panel */
        .timezone-info-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-top: 3rem;
            text-align: left;
        }

        .timezone-legend,
        .timezone-explanation {
            background: rgba(20, 20, 20, 0.9);
            border: 2px solid rgba(64, 156, 255, 0.4);
            border-radius: 15px;
            padding: 2rem;
            backdrop-filter: blur(10px);
        }

        .timezone-legend h4,
        .timezone-explanation h4 {
            color: #409cff;
            font-size: 1.3rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .legend-items {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .legend-color {
            width: 40px;
            height: 20px;
            border-radius: 5px;
            display: inline-block;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .legend-marker {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #ff4444;
            display: inline-block;
            box-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
        }

        .legend-text {
            color: #ddd;
            font-size: 0.95rem;
        }

        .timezone-explanation p {
            color: #ddd;
            line-height: 1.8;
            margin-bottom: 1.5rem;
        }

        .timezone-facts {
            list-style: none;
            padding-left: 0;
        }

        .timezone-facts li {
            color: #ddd;
            margin-bottom: 1rem;
            padding-left: 1.5rem;
            position: relative;
            line-height: 1.6;
        }

        .timezone-facts li::before {
            content: '\f0da';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            position: absolute;
            left: 0;
            color: #409cff;
        }

        .timezone-facts li strong {
            color: #67d7ff;
        }

        /* Responsive */
        @media (max-width: 992px) {
            .timezone-info-panel {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
        }
            /* Structure Canvas & HUD additions (ported) */
        #structure-3d-container { position: relative; }
        #structureCanvasMount { position: absolute; inset: 0; z-index: 1; }
        .structure-layer-labels { position: absolute; inset: 0; z-index: 25; pointer-events: none; font-family: 'Poppins', sans-serif; }
        .structure-layer-label { position: absolute; background: rgba(7,11,25,0.9); color: #fff; border-radius: 8px; padding: 0.4rem 0.8rem; font-size: 0.85rem; border: 1px solid rgba(255,255,255,0.2); display: flex; align-items: center; gap: 0.4rem; box-shadow: 0 6px 20px rgba(0,0,0,0.45); opacity: 0; transform: translate(-50%,-50%) scale(0.95); transition: opacity 0.3s ease, transform 0.3s ease; }
        .structure-layer-label.active { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        .structure-layer-label::after { content: ''; position: absolute; width: 1px; height: 40px; background: rgba(255,255,255,0.3); bottom: -40px; left: 50%; transform: translateX(-50%); }
    </style>
    <!-- Chatbot Widget CSS -->
    <link rel="stylesheet" href="chatbot-widget.css">
</head>
<body>

    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top site-navbar">
        <div class="container">
            <a class="navbar-brand site-name" href="index.html">Earth Motion Geography</a>

            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#mainNav">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="mainNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item me-3">
                        <a class="nav-link" href="index.html">
                            <i class="fa fa-home me-2"></i> Trang Ch·ªß
                        </a>
                    </li>
                    <li class="nav-item dropdown me-3">
                        <a class="nav-link dropdown-toggle" href="#" id="baiVietDropdown" role="button" data-bs-toggle="dropdown">
                            <i class="fas fa-book me-2"></i>B√†i Vi·∫øt
                        </a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="he-qua-chuyen-dong.html"><i class="fas fa-globe-americas me-2"></i>H·ªá qu·∫£ c·ªßa chuy·ªÉn ƒë·ªông Tr√°i ƒê·∫•t</a></li>
                            <li><a class="dropdown-item" href="kien-tao-mang.html"><i class="fas fa-layer-group me-2"></i>Thuy·∫øt ki·∫øn t·∫°o m·∫£ng v√† c·∫•u tr√∫c Tr√°i ƒê·∫•t</a></li>
                        </ul>
                    </li>
                    <li class="nav-item me-3">
                        <a class="nav-link" href="nguon.html">
                            <i class="fas fa-archive me-2"></i>T∆∞ Li·ªáu
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link tour-3d active" href="thamquan3d.html">
                            <i class="fas fa-vr-cardboard me-2"></i>M√¥ Ph·ªèng 3D
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Back Button -->
    <button class="back-btn" onclick="window.location.href='index.html'">
        <i class="fas fa-arrow-left me-2"></i>Quay L·∫°i
    </button>

    <!-- Hero Section -->
    <section class="hero-3d">
        <div class="container">
            <h1><i class="fas fa-vr-cardboard me-3"></i>M√¥ Ph·ªèng 3D</h1>
            <p>Kh√°m ph√° chuy·ªÉn ƒë·ªông c·ªßa Tr√°i ƒê·∫•t v√† c√°c h√†nh tinh kh√°c qua 4 m√¥ h√¨nh 3D kh√°c nhau. Ch·ªçn c·∫£nh b√™n d∆∞·ªõi ƒë·ªÉ kh√°m ph√°.</p>
        </div>
    </section>
    
    <!-- 360 Viewer -->
    <section class="viewer-container">
        <div class="container">
            <!-- Current Scene Title -->
            <div class="current-scene" id="current-scene-title">
                <h3>
                    <i class="fas fa-sun"></i>
                    <span id="scene-title-text">Ng√†y & ƒê√™m</span>
                </h3>
            </div>

            <div class="viewer-wrapper">
                <div style="position: relative;">
                    <!-- Day/Night 3D Container -->
                    <div id="daynight-3d-container"></div>

                    <!-- Seasons 3D Container -->
                    <div id="seasons-3d-container">
                        <!-- Season Control Buttons -->
                        <div class="season-controls">
                            <button class="season-btn-control active" onclick="changeSeason('spring')" data-season="spring">
                                üå∏ Xu√¢n Ph√¢n
                            </button>
                            <button class="season-btn-control" onclick="changeSeason('summer')" data-season="summer">
                                ‚òÄÔ∏è H·∫° Ch√≠
                            </button>
                            <button class="season-btn-control" onclick="changeSeason('autumn')" data-season="autumn">
                                üçÇ Thu Ph√¢n
                            </button>
                            <button class="season-btn-control" onclick="changeSeason('winter')" data-season="winter">
                                ‚ùÑÔ∏è ƒê√¥ng Ch√≠
                            </button>
                            <button class="season-btn-control" onclick="toggleSeasonAnimation()" id="animToggle">
                                ‚ñ∂Ô∏è T·ª± ƒê·ªông
                            </button>
                        </div>
                    </div>

                    <!-- Earth Structure 3D Container -->
                    <div id="structure-3d-container">
                        <div class="structure-canvas" id="structureCanvasMount"></div>
                        <!-- Structure HUD removed (match thamquan3d_1.html) -->
                        <div class="structure-layer-labels" id="structureLayerLabels"></div>
                        <!-- Current Layer Indicator Button -->
                        <div style="position:absolute; top:20px; left:50%; transform:translateX(-50%); z-index:20;">
                            <button class="structure-control-btn" id="structureCurrentLayerBtn" title="Ph√≥ng to l·ªõp hi·ªán t·∫°i v√† xem th√¥ng tin">
                                üîé L·ªõp hi·ªán t·∫°i: V·ªè Tr√°i ƒê·∫•t
                            </button>
                        </div>
                        <!-- Info Panel (hidden by default) -->
                        <div id="structureInfoPanel" class="structure-info-panel" style="display:none;">
                            <div class="structure-info-header">
                                <h2 id="structureInfoTitle">Th√¥ng tin l·ªõp</h2>
                                <p class="subtitle">Nh·∫•n n√∫t ƒë√≥ng ƒë·ªÉ quay l·∫°i kh√°m ph√°</p>
                            </div>
                            <div id="structureInfoContent" class="structure-info-content"></div>
                            <div style="text-align:center; margin-top:1rem;">
                                <button id="structureInfoClose" class="structure-control-btn">ƒê√≥ng</button>
                            </div>
                        </div>
                        <div class="structure-controls">
                            <button class="structure-control-btn" onclick="toggleStructureSeparation()" id="structureToggleBtn">
                                üåç T√°ch L·ªõp
                            </button>
                            <button class="structure-control-btn" onclick="toggleStructureAutoRotate()" id="structureRotateBtn">
                                üîÑ T·ª± ƒê·ªông Xoay
                            </button>
                            <button class="structure-control-btn" onclick="resetStructureView()">
                                ‚Ü∫ ƒê·∫∑t L·∫°i
                            </button>
                        </div>
                    </div>

                    <!-- Plate Tectonics 3D Container -->
                    <div id="plate-tectonics-container"></div>

                    <!-- Globe Container (Time Zone) -->
                    <div id="globe-container"></div>

                    <!-- Embed Iframe -->
                    <iframe
                        class="polycam-embed"
                        id="polycam-frame"
                        src="https://ciechanow.ski/earth-and-sun/"
                        frameborder="0"
                        allowfullscreen
                        allow="xr-spatial-tracking"
                        title="M√¥ Ph·ªèng Chuy·ªÉn ƒê·ªông Tr√°i ƒê·∫•t - 3D"
                        style="display: none;">
                    </iframe>

                    <!-- Loading Overlay -->
                    <div class="loading-overlay show" id="loading">
                        <div class="spinner"></div>
                        <div class="loading-text">ƒêang t·∫£i m√¥ h√¨nh 3D...</div>
                    </div>
                </div>

                <!-- Time Zone Information Panel -->
                <section id="gio-trai-dat" class="container text-center my-5" style="display: none;">

                  <!-- Time Zone Information Panel -->
                  <div class="timezone-info-panel">
                    <div class="timezone-legend">
                      <h4><i class="fas fa-info-circle"></i> Ch√∫ Gi·∫£i</h4>
                      <div class="legend-items">
                        <div class="legend-item">
                          <span class="legend-color" style="background-color: #ff0000;"></span>
                          <span class="legend-text">ƒê∆∞·ªùng kinh tuy·∫øn g·ªëc (GMT+0 - Greenwich)</span>
                        </div>
                        <div class="legend-item">
                          <span class="legend-color" style="background-color: #00ffff;"></span>
                          <span class="legend-text">C√°c ƒë∆∞·ªùng kinh tuy·∫øn m√∫i gi·ªù (m·ªói 15¬∞)</span>
                        </div>
                        <div class="legend-item">
                          <span class="legend-color" style="background-color: #ffff00;"></span>
                          <span class="legend-text">ƒê∆∞·ªùng x√≠ch ƒë·∫°o (0¬∞ vƒ© ƒë·ªô)</span>
                        </div>
                        <div class="legend-item">
                          <span class="legend-marker"></span>
                          <span class="legend-text">Th√†nh ph·ªë l·ªõn v·ªõi gi·ªù ƒë·ªãa ph∆∞∆°ng</span>
                        </div>
                        <div class="legend-item">
                          <span class="legend-color" style="background: linear-gradient(90deg, #ff00ff, #ff00ff); box-shadow: 0 0 15px #ff00ff;"></span>
                          <span class="legend-text"><strong>ƒê∆Ø·ªúNG ƒê·ªîI NG√ÄY QU·ªêC T·∫æ (180¬∞)</strong> - N∆°i c√≥ 2 ng√†y kh√°c nhau!</span>
                        </div>
                      </div>
                    </div>

                    <div class="timezone-explanation">
                      <h4><i class="fas fa-clock"></i> Gi·∫£i Th√≠ch M√∫i Gi·ªù</h4>
                      <p>
                        <strong>M√∫i gi·ªù</strong> l√† khu v·ª±c tr√™n Tr√°i ƒê·∫•t c√≥ c√πng gi·ªù chu·∫©n.
                        Tr√°i ƒê·∫•t ƒë∆∞·ª£c chia th√†nh 24 m√∫i gi·ªù, m·ªói m√∫i gi·ªù c√°ch nhau 15¬∞ kinh tuy·∫øn (t∆∞∆°ng ƒë∆∞∆°ng 1 gi·ªù).
                      </p>
                      <ul class="timezone-facts">
                        <li><strong>GMT (Greenwich Mean Time):</strong> Gi·ªù chu·∫©n t·∫°i kinh tuy·∫øn g·ªëc 0¬∞ (ƒëi qua Greenwich, Anh)</li>
                        <li><strong>Vi·ªát Nam:</strong> GMT+7 (nhanh h∆°n Greenwich 7 gi·ªù)</li>
                        <li><strong>T√≠nh to√°n:</strong> M·ªói 15¬∞ = 1 gi·ªù ch√™nh l·ªách (360¬∞ √∑ 24 gi·ªù = 15¬∞/gi·ªù)</li>
                        <li><strong>H∆∞·ªõng quay:</strong> Tr√°i ƒê·∫•t quay theo h∆∞·ªõng T√¢y ‚Üí ƒê√¥ng, n√™n m√∫i gi·ªù ph√≠a ƒê√¥ng nhanh h∆°n</li>
                      </ul>

                      <h4 style="color: #ff00ff; margin-top: 2rem;"><i class="fas fa-calendar-day"></i> ƒê∆∞·ªùng ƒê·ªïi Ng√†y Qu·ªëc T·∫ø</h4>
                      <p>
                        <strong style="color: #ff00ff;">ƒê∆∞·ªùng ƒê·ªïi Ng√†y Qu·ªëc T·∫ø (International Date Line)</strong> l√† ƒë∆∞·ªùng kinh tuy·∫øn 180¬∞ -
                        ƒë·ªëi di·ªán v·ªõi kinh tuy·∫øn g·ªëc GMT. ƒê√¢y l√† n∆°i k·ª≥ di·ªáu nh·∫•t tr√™n Tr√°i ƒê·∫•t v·ªÅ m√∫i gi·ªù!
                      </p>
                      <ul class="timezone-facts">
                        <li><strong style="color: #ff00ff;">2 b√™n = 2 ng√†y:</strong> Ph√≠a T√¢y (GMT+12) l√† NG√ÄY MAI, Ph√≠a ƒê√¥ng (GMT-12) l√† H√îM QUA</li>
                        <li><strong>ƒêi t·ª´ ƒê√¥ng ‚Üí T√¢y:</strong> Qua ƒë∆∞·ªùng n√†y b·∫°n s·∫Ω "nh·∫£y" sang ng√†y mai (v√≠ d·ª•: Th·ª© 2 ‚Üí Th·ª© 3)</li>
                        <li><strong>ƒêi t·ª´ T√¢y ‚Üí ƒê√¥ng:</strong> Qua ƒë∆∞·ªùng n√†y b·∫°n s·∫Ω "l√πi" v·ªÅ h√¥m qua (v√≠ d·ª•: Th·ª© 3 ‚Üí Th·ª© 2)</li>
                        <li><strong>V√≠ d·ª• th·ª±c t·∫ø:</strong> N·∫øu b·∫°n bay t·ª´ Nh·∫≠t B·∫£n sang M·ªπ qua Th√°i B√¨nh D∆∞∆°ng, b·∫°n s·∫Ω "s·ªëng l·∫°i" 1 ng√†y!</li>
                        <li><strong>T·∫°i sao c·∫ßn c√≥:</strong> V√¨ Tr√°i ƒê·∫•t tr√≤n, ph·∫£i c√≥ 1 ƒëi·ªÉm ƒë·ªÉ "reset" ng√†y, n·∫øu kh√¥ng th√¨ c·ª© ƒëi v√≤ng quanh th·∫ø gi·ªõi s·∫Ω l·ªách ng√†y!</li>
                      </ul>
                    </div>
                  </div>
                </section>

                <!-- Seasons Information Panel -->
                <section id="seasons-info" class="container my-5" style="display:none;">
                  <div class="timezone-info-panel">
                    <div class="timezone-legend">
                      <h4><i class="fas fa-leaf"></i> 4 M√πa Trong NƒÉm</h4>
                      <div class="legend-items">
                        <div class="legend-item">
                          <span class="legend-color" style="background-color: #00ff00;"></span>
                          <span class="legend-text"><strong>üå∏ XU√ÇN PH√ÇN (21/03):</strong> M·∫∑t Tr·ªùi chi·∫øu vu√¥ng g√≥c x√≠ch ƒë·∫°o</span>
                        </div>
                        <div class="legend-item">
                          <span class="legend-color" style="background-color: #ff0000;"></span>
                          <span class="legend-text"><strong>‚òÄÔ∏è H·∫† CH√ç (21/06):</strong> B·∫Øc b√°n c·∫ßu nghi√™ng V·ªÄ M·∫∑t Tr·ªùi</span>
                        </div>
                        <div class="legend-item">
                          <span class="legend-color" style="background-color: #ff8800;"></span>
                          <span class="legend-text"><strong>üçÇ THU PH√ÇN (23/09):</strong> L·∫°i chi·∫øu vu√¥ng g√≥c x√≠ch ƒë·∫°o</span>
                        </div>
                        <div class="legend-item">
                          <span class="legend-color" style="background-color: #0088ff;"></span>
                          <span class="legend-text"><strong>‚ùÑÔ∏è ƒê√îNG CH√ç (22/12):</strong> Nam b√°n c·∫ßu nghi√™ng V·ªÄ M·∫∑t Tr·ªùi</span>
                        </div>
                      </div>
                    </div>

                    <div class="timezone-explanation">
                      <h4><i class="fas fa-sun"></i> T·∫°i Sao C√≥ C√°c M√πa?</h4>
                      <p>
                        <strong>Nguy√™n nh√¢n ch√≠nh:</strong> Tr·ª•c Tr√°i ƒê·∫•t <strong style="color: #ff00ff;">NGHI√äNG 23.5¬∞</strong> so v·ªõi m·∫∑t ph·∫≥ng qu·ªπ ƒë·∫°o!
                        ƒê√¢y l√† l√Ω do duy nh·∫•t t·∫°o ra 4 m√πa trong nƒÉm.
                      </p>
                      <ul class="timezone-facts">
                        <li><strong style="color: #00ff00;">Xu√¢n/Thu Ph√¢n:</strong> Ng√†y = ƒê√™m (12 gi·ªù m·ªói b√™n), M·∫∑t Tr·ªùi chi·∫øu th·∫≥ng x√≠ch ƒë·∫°o</li>
                        <li><strong style="color: #ff0000;">H·∫° Ch√≠:</strong> Ng√†y d√†i nh·∫•t (B·∫Øc b√°n c·∫ßu), M·∫∑t Tr·ªùi l√™n cao nh·∫•t ‚Üí N√ìNG</li>
                        <li><strong style="color: #0088ff;">ƒê√¥ng Ch√≠:</strong> ƒê√™m d√†i nh·∫•t (B·∫Øc b√°n c·∫ßu), M·∫∑t Tr·ªùi th·∫•p ‚Üí L·∫†NH</li>
                        <li><strong>B·∫Øc & Nam ƒë·ªëi l·∫≠p:</strong> B·∫Øc b√°n c·∫ßu l√† h√® th√¨ Nam b√°n c·∫ßu l√† ƒë√¥ng (v√† ng∆∞·ª£c l·∫°i)</li>
                        <li><strong>Tr·ª•c KH√îNG nghi√™ng?</strong> ‚Üí S·∫Ω KH√îNG c√≥ m√πa, ng√†y/ƒë√™m lu√¥n b·∫±ng nhau c·∫£ nƒÉm!</li>
                        <li><strong>Kho·∫£ng c√°ch Tr√°i ƒê·∫•t - M·∫∑t Tr·ªùi:</strong> KH√îNG ph·∫£i nguy√™n nh√¢n ch√≠nh (v√¨ qu·ªπ ƒë·∫°o g·∫ßn tr√≤n)</li>
                      </ul>
                    </div>
                  </div>
                </section>
            </div>

            <!-- Scene Selector - 5 C·∫£nh -->
            <div class="scene-selector">
                <button class="scene-btn active" onclick="changeScene('ngaydem')" data-scene="ngaydem">
                    <i class="fas fa-sun"></i>
                    <span class="scene-name">Ng√†y & ƒê√™m</span>
                    <span class="scene-desc">Tr√°i ƒê·∫•t quay quanh tr·ª•c - M·∫∑t Tr·ªùi & M·∫∑t TrƒÉng</span>
                </button>

                <button class="scene-btn" onclick="changeScene('cau-tao-loi')" data-scene="cau-tao-loi">
                    <i class="fas fa-layer-group"></i>
                    <span class="scene-name">C·∫•u T·∫°o L√µi</span>
                    <span class="scene-desc">6 l·ªõp: V·ªè - Manti - L√µi (ngo√†i & trong)</span>
                </button>

                <button class="scene-btn" onclick="changeScene('gio')" data-scene="gio">
                    <i class="fas fa-clock"></i>
                    <span class="scene-name">Gi·ªù Tr√™n Tr√°i ƒê·∫•t</span>
                    <span class="scene-desc">24 m√∫i gi·ªù - Kinh tuy·∫øn GMT 0¬∞ - ƒê∆∞·ªùng ƒë·ªïi ng√†y 180¬∞</span>
                </button>

                <button class="scene-btn" onclick="changeScene('cac-mua-trong-nam')" data-scene="cac-mua-trong-nam">
                    <i class="fas fa-leaf"></i>
                    <span class="scene-name">C√°c M√πa Trong NƒÉm</span>
                    <span class="scene-desc">Tr·ª•c Tr√°i ƒê·∫•t nghi√™ng 23.5¬∞ - Xu√¢n, H·∫°, Thu, ƒê√¥ng</span>
                </button>

                <button class="scene-btn" onclick="scrollToVideoSection()" data-scene="video">
                    <i class="fas fa-video"></i>
                    <span class="scene-name">H·ªá Qu·∫£ Di Chuy·ªÉn M·∫£ng Ki·∫øn T·∫°o</span>
                    <span class="scene-desc">Video 3D: M·∫£ng va ch·∫°m - M·∫£ng tr∆∞·ª£t - M·∫£ng t√°ch r·ªùi</span>
                </button>
            </div>

            <!-- Instructions -->
            <div class="instructions">
                <h3><i class="fas fa-info-circle me-2"></i>H∆∞·ªõng D·∫´n S·ª≠ D·ª•ng</h3>
                <div class="instruction-grid">
                    <div class="instruction-item">
                        <i class="fas fa-mouse"></i>
                        <p><strong>M√°y t√≠nh:</strong> K√©o chu·ªôt ƒë·ªÉ xoay Tr√°i ƒê·∫•t</p>
                    </div>
                    <div class="instruction-item">
                        <i class="fas fa-hand-pointer"></i>
                        <p><strong>ƒêi·ªán tho·∫°i:</strong> Vu·ªët ƒë·ªÉ xoay m√¥ h√¨nh</p>
                    </div>
                    <div class="instruction-item">
                        <i class="fas fa-search-plus"></i>
                        <p><strong>Ph√≥ng to/Thu nh·ªè:</strong> Cu·ªôn chu·ªôt ho·∫∑c pinch</p>
                    </div>
                    <div class="instruction-item">
                        <i class="fas fa-expand"></i>
                        <p><strong>To√†n m√†n h√¨nh:</strong> Nh·∫•n n√∫t ·ªü g√≥c d∆∞·ªõi ph·∫£i</p>
                    </div>
                </div>
            </div>

            <!-- Time Scale Information -->
            <div class="time-scale-info">
                <h4><i class="fas fa-clock"></i> T·ªâ L·ªá Th·ªùi Gian M√¥ Ph·ªèng</h4>
                <p style="color: #ccc; margin-bottom: 1.5rem;">So s√°nh th·ªùi gian th·ª±c t·∫ø v·ªõi th·ªùi gian trong m√¥ ph·ªèng 3D "Ng√†y & ƒê√™m":</p>
                <div class="time-scale-grid">
                    <div class="time-scale-item">
                        <div class="label"><i class="fas fa-sync-alt"></i> Tr√°i ƒê·∫•t T·ª± Quay</div>
                        <div class="value">1 ng√†y = 2.2 ph√∫t</div>
                        <div class="real-time">24 gi·ªù th·ª±c t·∫ø = ~131 gi√¢y m√¥ ph·ªèng</div>
                    </div>
                    <div class="time-scale-item">
                        <div class="label"><i class="fas fa-sun"></i> Tr√°i ƒê·∫•t Quay Quanh M·∫∑t Tr·ªùi</div>
                        <div class="value">1 nƒÉm = 5.8 ph√∫t</div>
                        <div class="real-time">365 ng√†y th·ª±c t·∫ø = ~349 gi√¢y m√¥ ph·ªèng</div>
                    </div>
                    <div class="time-scale-item">
                        <div class="label"><i class="fas fa-moon"></i> M·∫∑t TrƒÉng Quay Quanh Tr√°i ƒê·∫•t</div>
                        <div class="value">1 chu k·ª≥ = 1.2 ph√∫t</div>
                        <div class="real-time">27.3 ng√†y th·ª±c t·∫ø = ~70 gi√¢y m√¥ ph·ªèng</div>
                    </div>
                    <div class="time-scale-item">
                        <div class="label"><i class="fas fa-info-circle"></i> T·ªëc ƒê·ªô M√¥ Ph·ªèng</div>
                        <div class="value">Nhanh h∆°n ~600-1000 l·∫ßn</div>
                        <div class="real-time">ƒê·ªÉ d·ªÖ quan s√°t chuy·ªÉn ƒë·ªông</div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Video Section: H·ªá Qu·∫£ Di Chuy·ªÉn M·∫£ng Ki·∫øn T·∫°o -->
    <section id="video-section">
        <div class="container">
            <div class="video-section-title">
                <i class="fas fa-video"></i>
                H·ªá Qu·∫£ Di Chuy·ªÉn M·∫£ng Ki·∫øn T·∫°o
            </div>
            <div class="video-cards-wrapper">
                <div class="video-card" data-video="0">
                    <div class="video-card-icon">üîÑ</div>
                    <div class="video-card-text">
                        <div class="video-card-title">Ranh Gi·ªõi H·ªôi T·ª•</div>
                        <div class="video-card-desc">
                            <strong>ƒê·ªãnh nghƒ©a:</strong> Hai m·∫£ng ki·∫øn t·∫°o di chuy·ªÉn l·∫°i g·∫ßn nhau v√† va ch·∫°m.<br>
                            <strong>H·ªá qu·∫£:</strong> T·∫°o ra d√£y n√∫i cao, n√∫i l·ª≠a, ƒë·ªông ƒë·∫•t m·∫°nh, v√† r√£nh ƒë·∫°i d∆∞∆°ng s√¢u.<br>
                            <strong>V√≠ d·ª•:</strong> D√£y Himalaya (·∫§n ƒê·ªô - √Å), R√£nh Mariana (s√¢u nh·∫•t th·∫ø gi·ªõi -11km).
                        </div>
                    </div>
                </div>
                <div class="video-card" data-video="1">
                    <div class="video-card-icon">üåä</div>
                    <div class="video-card-text">
                        <div class="video-card-title">M·∫£ng ƒê·∫°i D∆∞∆°ng ‚Üî L·ª•c ƒê·ªãa</div>
                        <div class="video-card-desc">
                            <strong>ƒê·ªãnh nghƒ©a:</strong> M·∫£ng ƒë·∫°i d∆∞∆°ng (n·∫∑ng h∆°n) l·∫∑n xu·ªëng d∆∞·ªõi m·∫£ng l·ª•c ƒë·ªãa (nh·∫π h∆°n).<br>
                            <strong>H·ªá qu·∫£:</strong> N√∫i l·ª≠a d·ªçc b·ªù bi·ªÉn, ƒë·ªông ƒë·∫•t m·∫°nh, s√≥ng th·∫ßn, r√£nh ƒë·∫°i d∆∞∆°ng.<br>
                            <strong>V√≠ d·ª•:</strong> D√£y n√∫i l·ª≠a Andes (Nam M·ªπ), V√†nh ƒëai l·ª≠a Th√°i B√¨nh D∆∞∆°ng.
                        </div>
                    </div>
                </div>
                <div class="video-card" data-video="2">
                    <div class="video-card-icon">üåÄ</div>
                    <div class="video-card-text">
                        <div class="video-card-title">Hai M·∫£ng ƒê·∫°i D∆∞∆°ng</div>
                        <div class="video-card-desc">
                            <strong>ƒê·ªãnh nghƒ©a:</strong> Hai m·∫£ng ƒë·∫°i d∆∞∆°ng va ch·∫°m, m·∫£ng gi√† h∆°n (n·∫∑ng h∆°n) l·∫∑n xu·ªëng.<br>
                            <strong>H·ªá qu·∫£:</strong> Chu·ªói ƒë·∫£o n√∫i l·ª≠a h√¨nh v√≤ng cung, ƒë·ªông ƒë·∫•t d∆∞·ªõi bi·ªÉn, r√£nh s√¢u.<br>
                            <strong>V√≠ d·ª•:</strong> Qu·∫ßn ƒë·∫£o Nh·∫≠t B·∫£n, Philippines, Indonesia (v√†nh ƒëai l·ª≠a).
                        </div>
                    </div>
                </div>
                <div class="video-card" data-video="3">
                    <div class="video-card-icon">‚õ∞Ô∏è</div>
                    <div class="video-card-text">
                        <div class="video-card-title">Hai M·∫£ng L·ª•c ƒê·ªãa</div>
                        <div class="video-card-desc">
                            <strong>ƒê·ªãnh nghƒ©a:</strong> Hai m·∫£ng l·ª•c ƒë·ªãa (c√πng nh·∫π) va ch·∫°m v√† n√©n v√†o nhau.<br>
                            <strong>H·ªá qu·∫£:</strong> T·∫°o d√£y n√∫i cao nh·∫•t th·∫ø gi·ªõi, ƒë·ªông ƒë·∫•t m·∫°nh, KH√îNG c√≥ n√∫i l·ª≠a.<br>
                            <strong>V√≠ d·ª•:</strong> Himalaya (cao nh·∫•t th·∫ø gi·ªõi - 8,849m), Alps, Zagros.
                        </div>
                    </div>
                </div>
                <div class="video-card" data-video="4">
                    <div class="video-card-icon">‚ÜîÔ∏è</div>
                    <div class="video-card-text">
                        <div class="video-card-title">Ranh Gi·ªõi Tr∆∞·ª£t Ngang</div>
                        <div class="video-card-desc">
                            <strong>ƒê·ªãnh nghƒ©a:</strong> Hai m·∫£ng tr∆∞·ª£t ngang qua nhau theo h∆∞·ªõng ng∆∞·ª£c chi·ªÅu.<br>
                            <strong>H·ªá qu·∫£:</strong> ƒê·ªông ƒë·∫•t c·ª±c m·∫°nh, ƒë·ª©t g√£y ƒë·ªãa h√¨nh, KH√îNG t·∫°o n√∫i cao hay n√∫i l·ª≠a.<br>
                            <strong>V√≠ d·ª•:</strong> ƒê·ª©t g√£y San Andreas (California - M·ªπ), ƒë·ªông ƒë·∫•t 1906 ph√° h·ªßy San Francisco.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Video Modal -->
    <div class="video-modal-overlay" id="videoModal">
        <div class="video-modal-content">
            <button class="video-modal-close" id="videoCloseBtn">&times;</button>
            <div class="video-player-container">
                <video id="videoPlayer" controls preload="auto" playsinline webkit-playsinline style="width:100%; height:100%; object-fit:contain; background:black;">
                    <source src="" type="video/mp4">
                    Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ video.
                </video>
            </div>
            <div class="video-modal-controls">
                <button class="video-control-btn" id="videoFullscreenBtn" title="To√†n m√†n h√¨nh">‚õ∂</button>
            </div>
        </div>
    </div>

    <!-- Ph·∫ßn m·ªõi: M√¥ t·∫£ chuy·ªÉn ƒë·ªông c·ªßa c√°c h√†nh tinh kh√°c -->
    <section class="planet-description">
        <div class="container">
            <h2>M√¥ T·∫£ Chuy·ªÉn ƒê·ªông C·ªßa C√°c H√†nh Tinh Kh√°c Trong H·ªá M·∫∑t Tr·ªùi</h2>
            <div class="planet-grid">
                <div class="planet-card">
                    <h3><i class="fas fa-venus"></i> Sao Th·ªßy</h3>
                    <p>Sao Th·ªßy l√† h√†nh tinh g·∫ßn M·∫∑t Tr·ªùi nh·∫•t, v·ªõi chu k·ª≥ quay quanh tr·ª•c r·∫•t ch·∫≠m (58,6 ng√†y Tr√°i ƒê·∫•t) nh∆∞ng chuy·ªÉn ƒë·ªông quay quanh M·∫∑t Tr·ªùi nhanh (88 ng√†y).</p>
                    <ul>
                        <li>Chu k·ª≥ quay quanh tr·ª•c: 58,6 ng√†y</li>
                        <li>Chu k·ª≥ quay quanh M·∫∑t Tr·ªùi: 88 ng√†y</li>
                        <li>H·ªá qu·∫£: Nhi·ªát ƒë·ªô c·ª±c ƒëoan gi·ªØa ng√†y v√† ƒë√™m</li>
                    </ul>
                </div>

                <div class="planet-card">
                    <h3><i class="fas fa-venus"></i> Sao Kim</h3>
                    <p>Sao Kim quay ng∆∞·ª£c chi·ªÅu v·ªõi h·∫ßu h·∫øt c√°c h√†nh tinh kh√°c, v·ªõi chu k·ª≥ quay quanh tr·ª•c d√†i (243 ng√†y) v√† quay quanh M·∫∑t Tr·ªùi trong 225 ng√†y.</p>
                    <ul>
                        <li>Chu k·ª≥ quay quanh tr·ª•c: 243 ng√†y (ng∆∞·ª£c chi·ªÅu)</li>
                        <li>Chu k·ª≥ quay quanh M·∫∑t Tr·ªùi: 225 ng√†y</li>
                        <li>H·ªá qu·∫£: Hi·ªáu ·ª©ng nh√† k√≠nh m·∫°nh, nhi·ªát ƒë·ªô b·ªÅ m·∫∑t cao</li>
                    </ul>
                </div>

                <div class="planet-card">
                    <h3><i class="fas fa-mars"></i> Sao H·ªèa</h3>
                    <p>Sao H·ªèa c√≥ ng√†y g·∫ßn gi·ªëng Tr√°i ƒê·∫•t (24,6 gi·ªù), nh∆∞ng nƒÉm d√†i h∆°n (687 ng√†y), d·∫´n ƒë·∫øn m√πa k√©o d√†i v√† b√£o b·ª•i l·ªõn.</p>
                    <ul>
                        <li>Chu k·ª≥ quay quanh tr·ª•c: 24,6 gi·ªù</li>
                        <li>Chu k·ª≥ quay quanh M·∫∑t Tr·ªùi: 687 ng√†y</li>
                        <li>H·ªá qu·∫£: M√πa k√©o d√†i, b√£o b·ª•i to√†n c·∫ßu</li>
                    </ul>
                </div>

                <div class="planet-card">
                    <h3><i class="fas fa-jupiter"></i> Sao M·ªôc</h3>
                    <p>Sao M·ªôc quay quanh tr·ª•c r·∫•t nhanh (10 gi·ªù), t·∫°o ra c√°c d·∫£i m√¢y v√† b√£o l·ªõn, quay quanh M·∫∑t Tr·ªùi trong 12 nƒÉm.</p>
                    <ul>
                        <li>Chu k·ª≥ quay quanh tr·ª•c: 10 gi·ªù</li>
                        <li>Chu k·ª≥ quay quanh M·∫∑t Tr·ªùi: 12 nƒÉm</li>
                        <li>H·ªá qu·∫£: B√£o kh·ªïng l·ªì nh∆∞ V·∫øt ƒê·ªè L·ªõn</li>
                    </ul>
                </div>
            </div>
        </div>
    </section>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // Danh s√°ch 5 c·∫£nh v·ªõi link embed th·ª±c t·∫ø v·ªÅ m√¥ ph·ªèng Tr√°i ƒê·∫•t v√† h√†nh tinh
        const scenes = {
            ngaydem: {
                url: "", // Custom Day/Night scene
                title: "S·ª± Lu√¢n Phi√™n C·ªßa Ng√†y V√† ƒê√™m - C√≥ M·∫∑t TrƒÉng",
                icon: "fa-sun"
            },
            'cau-tao-loi': {
                url: "", // Custom Earth Structure scene
                title: "C·∫•u T·∫°o L√µi Tr√°i ƒê·∫•t",
                icon: "fa-layer-group"
            },
            gio: {
                url: "", // No URL for custom globe scene
                title: "Gi·ªù Tr√™n Tr√°i ƒê·∫•t",
                icon: "fa-clock"
            },
            'cac-mua-trong-nam': {
                url: "", // Custom Seasons scene
                title: "C√°c M√πa Trong NƒÉm",
                icon: "fa-leaf"
            }
        };

        // Global variables for Earth 3D scene
        let earthScene, earthCamera, earthRenderer, earthMesh, cloudsMesh, earthControls;
        let earthAnimationId = null;

        // Split Earth feature variables
        let isSplit = false;
        let leftHemisphere, rightHemisphere; // Two hemispheres with cross-sections
        let leftCrossSection, rightCrossSection; // Cross-sections (stored separately to prevent rotation)
        let layerLabels = []; // Labels for each layer
        let raycaster, mouse; // For click detection
        let splitAnimationProgress = 0; // 0 to 1 for smooth animation
        let middleContentGroup; // Group ƒë·ªÉ ch·ª©a n·ªôi dung ·ªü gi·ªØa 2 n·ª≠a Tr√°i ƒê·∫•t

        // Global variables for Day/Night 3D scene
        let dayNightScene, dayNightCamera, dayNightRenderer, dayNightEarth, dayNightClouds, dayNightControls, sunMesh;
        let sunGlowLayers = []; // Array for multiple smooth glow layers
        let earthOrbitGroup; // Group for Earth orbit around Sun
        let moonMesh, moonOrbitGroup; // Moon and its orbit
        // Satellite ƒë√£ b·ªã x√≥a theo y√™u c·∫ßu
        let dayNightAnimationId = null;

        // Sun split feature variables
        let isSunSplit = false;
        let leftSunHalf, rightSunHalf;
        let sunRaycaster, sunMouse;
        let sunSplitProgress = 0;

        // Global variables for Time Zone Globe scene
        let timeZoneScene, timeZoneCamera, timeZoneRenderer, timeZoneEarth, timeZoneControls;
        let timeZoneAnimationId = null;

        // Global variables for Seasons 3D scene
        let seasonsScene, seasonsCamera, seasonsRenderer, seasonsControls;
        let seasonsAnimationId = null;

        // Global variables for Earth Structure scene
        let structureSceneObj = null;
        const STRUCTURE_TEXTURE_URLS = {
            day: 'https://unpkg.com/three-globe@2.24.9/example/img/earth-blue-marble.jpg',
            night: 'https://raw.githubusercontent.com/turban/webgl-earth/master/images/earthlights1k.jpg',
            normal: 'https://threejsfundamentals.org/threejs/resources/images/earth-normal-2048.jpg',
            bump: 'https://unpkg.com/three-globe@2.24.9/example/img/earth-topology.png',
            specular: 'https://unpkg.com/three-globe@2.24.9/example/img/earth-water.png',
            clouds: 'https://unpkg.com/three-globe@2.24.9/example/img/earth-clouds.png'
        };
        const STRUCTURE_FALLBACK_COLORS = {
            day: '#2a72ff',
            night: '#05081c',
            normal: '#8888ff',
            bump: '#555555',
            specular: '#d9d9d9',
            clouds: 'rgba(255,255,255,0.8)'
        };
        const STRUCTURE_LAYER_INFO = {
            inner: {
                title: 'L√µi Trong',
                icon: 'üî•',
                summary: 'Kh·ªëi s·∫Øt‚Äìniken r·∫Øn v·ªõi nhi·ªát ƒë·ªô ngang b·ªÅ m·∫∑t M·∫∑t Tr·ªùi, t·∫°o th√†nh t√¢m Tr√°i ƒê·∫•t.',
                stats: [
                    { label: 'B√°n k√≠nh', value: '1,220 km' },
                    { label: 'Tr·∫°ng th√°i', value: 'R·∫Øn' },
                    { label: 'Nhi·ªát ƒë·ªô', value: '5.000 ‚Äì 7.000¬∞C' },
                    { label: '√Åp su·∫•t', value: '330 ‚Äì 360 GPa' }
                ]
            },
            outer: {
                title: 'L√µi Ngo√†i',
                icon: 'üåã',
                summary: 'L·ªõp kim lo·∫°i l·ªèng chuy·ªÉn ƒë·ªông m·∫°nh, t·∫°o n√™n t·ª´ tr∆∞·ªùng bao b·ªçc h√†nh tinh.',
                stats: [
                    { label: 'ƒê·ªô d√†y', value: '2.300 km' },
                    { label: 'Tr·∫°ng th√°i', value: 'L·ªèng' },
                    { label: 'Nhi·ªát ƒë·ªô', value: '4.000 ‚Äì 6.000¬∞C' },
                    { label: 'Vai tr√≤', value: 'Sinh ra t·ª´ tr∆∞·ªùng' }
                ]
            },
            mantle: {
                title: 'Manti',
                icon: 'ü™®',
                summary: 'L·ªõp d√†y nh·∫•t v·ªõi magma b√°n l·ªèng ƒë·ªëi l∆∞u ch·∫≠m.',
                stats: [
                    { label: 'ƒê·ªô d√†y', value: '2.900 km' },
                    { label: 'Tr·∫°ng th√°i', value: 'B√°n l·ªèng' },
                    { label: 'Nhi·ªát ƒë·ªô', value: '500 ‚Äì 4.000¬∞C' },
                    { label: 'ƒê·∫∑c ƒëi·ªÉm', value: 'ƒê·ªëi l∆∞u magma' }
                ]
            },
            crust: {
                title: 'V·ªè Tr√°i ƒê·∫•t',
                icon: 'üåç',
                summary: 'L·ªõp m·ªèng nh·∫•t, n∆°i t·ªìn t·∫°i ƒë·∫°i d∆∞∆°ng, l·ª•c ƒë·ªãa v√† to√†n b·ªô s·ª± s·ªëng ch√∫ng ta bi·∫øt.',
                stats: [
                    { label: 'ƒê·ªô d√†y', value: '5 ‚Äì 70 km' },
                    { label: 'Tr·∫°ng th√°i', value: 'R·∫Øn' },
                    { label: 'Nhi·ªát ƒë·ªô', value: '0 ‚Äì 400¬∞C' },
                    { label: 'Th√†nh ph·∫ßn', value: 'ƒê√° & kho√°ng v·∫≠t' }
                ]
            }
        };

        // Initialize 3D Earth scene
        function initEarth3D() {
            const container = document.getElementById('earth-3d-container');
            if (!container) {
                console.error('Container not found!');
                return;
            }

            if (earthScene) {
                console.log('Scene already initialized');
                return;
            }

            console.log('Initializing Earth 3D...');

            // Clear container
            container.innerHTML = '';

            // Create scene
            earthScene = new THREE.Scene();
            earthScene.background = new THREE.Color(0x000000);

            // Create camera
            const aspect = container.clientWidth / container.clientHeight;
            earthCamera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            earthCamera.position.z = 2.5;

            // Create renderer
            earthRenderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: false
            });
            earthRenderer.setSize(container.clientWidth, container.clientHeight);
            earthRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(earthRenderer.domElement);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            earthScene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(5, 3, 5);
            earthScene.add(sunLight);

            // Create Earth sphere
            const geometry = new THREE.SphereGeometry(1, 64, 64);

            // Load textures
            const textureLoader = new THREE.TextureLoader();

            // Start with basic material, then upgrade when textures load
            const material = new THREE.MeshPhongMaterial({
                color: 0x2233ff,
                emissive: 0x112244,
                shininess: 5
            });

            earthMesh = new THREE.Mesh(geometry, material);
            earthScene.add(earthMesh);

            // Load realistic Earth texture
            textureLoader.load(
                'https://unpkg.com/three-globe@2.24.9/example/img/earth-blue-marble.jpg',
                function(texture) {
                    console.log('Earth texture loaded!');
                    earthMesh.material.map = texture;
                    earthMesh.material.color = new THREE.Color(0xffffff);
                    earthMesh.material.needsUpdate = true;
                },
                undefined,
                function(error) {
                    console.error('Error loading earth texture:', error);
                }
            );

            // Add clouds layer
            const cloudsGeometry = new THREE.SphereGeometry(1.01, 64, 64);
            const cloudsMaterial = new THREE.MeshPhongMaterial({
                transparent: true,
                opacity: 0,
                depthWrite: false
            });

            cloudsMesh = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
            earthScene.add(cloudsMesh);

            // Load clouds texture
            textureLoader.load(
                'https://unpkg.com/three-globe@2.24.9/example/img/earth-topology.png',
                function(texture) {
                    console.log('Clouds texture loaded!');
                    cloudsMesh.material.map = texture;
                    cloudsMesh.material.opacity = 0.15;
                    cloudsMesh.material.needsUpdate = true;
                },
                undefined,
                function(error) {
                    console.error('Error loading clouds texture:', error);
                }
            );

            // Add stars
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.7,
                sizeAttenuation: true
            });

            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position',
                new THREE.Float32BufferAttribute(starsVertices, 3)
            );

            const starField = new THREE.Points(starsGeometry, starsMaterial);
            earthScene.add(starField);

            // Add orbit controls
            earthControls = new THREE.OrbitControls(earthCamera, earthRenderer.domElement);
            earthControls.enableDamping = true;
            earthControls.dampingFactor = 0.05;
            earthControls.minDistance = 1.5;
            earthControls.maxDistance = 5;
            earthControls.enablePan = false;
            earthControls.autoRotate = false;

            // Animation loop
            function animateEarth() {
                earthAnimationId = requestAnimationFrame(animateEarth);

                // Rotate earth - CH·∫¨M H∆†N
                if (earthMesh && earthMesh.visible) {
                    earthMesh.rotation.y += 0.0005; // Gi·∫£m t·ª´ 0.002 xu·ªëng 0.0005 (ch·∫≠m h∆°n 4 l·∫ßn)
                }
                if (cloudsMesh && cloudsMesh.visible) {
                    cloudsMesh.rotation.y += 0.0006; // Gi·∫£m t·ª´ 0.0025 xu·ªëng 0.0006 (ch·∫≠m h∆°n ~4 l·∫ßn)
                }

                // Animate CUTTING EARTH IN HALF - smooth split animation
                if (isSplit && leftHemisphere && rightHemisphere) {
                    const targetPosX = 2.5; // Kho·∫£ng c√°ch l·ªõn gi·ªØa 2 n·ª≠a - ƒë·ªÉ ch·ª´a ch·ªó th√™m n·ªôi dung

                    // Smoothly animate split progress
                    if (splitAnimationProgress < 1) {
                        splitAnimationProgress += 0.02; // Smooth animation speed
                        if (splitAnimationProgress > 1) splitAnimationProgress = 1;
                    }

                    const easeProgress = easeInOutCubic(splitAnimationProgress);

                    // Move hemispheres apart to reveal cross-sections
                    leftHemisphere.position.x = -targetPosX * easeProgress;
                    rightHemisphere.position.x = targetPosX * easeProgress;

                    // TR√ÅI ƒê·∫§T D·ª™NG H·∫≤N - KH√îNG QUAY KHI T√ÅCH
                    // (removed rotation code)

                    // NO LABELS - only clear ring boundaries show the layers

                } else if (!isSplit && leftHemisphere && rightHemisphere) {
                    // Smoothly animate back together
                    if (splitAnimationProgress > 0) {
                        splitAnimationProgress -= 0.02;
                        if (splitAnimationProgress < 0) splitAnimationProgress = 0;
                    }

                    const easeProgress = easeInOutCubic(splitAnimationProgress);

                    // Move hemispheres back
                    const targetPosX = 2.5; // Gi·ªëng kho·∫£ng c√°ch khi t√°ch
                    leftHemisphere.position.x = -targetPosX * easeProgress;
                    rightHemisphere.position.x = targetPosX * easeProgress;
                }

                // Easing function for smooth animation
                function easeInOutCubic(t) {
                    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                }

                earthControls.update();
                earthRenderer.render(earthScene, earthCamera);
            }
            animateEarth();

            // Handle resize
            const resizeHandler = () => {
                if (container.style.display !== 'none' && earthRenderer) {
                    const width = container.clientWidth;
                    const height = container.clientHeight;

                    earthCamera.aspect = width / height;
                    earthCamera.updateProjectionMatrix();
                    earthRenderer.setSize(width, height);
                }
            };

            window.addEventListener('resize', resizeHandler);

            // ============================================
            // SPLIT EARTH FEATURE - C·∫•u tr√∫c b√™n trong Tr√°i ƒê·∫•t
            // ============================================

            // Initialize raycaster and mouse for click detection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Create Earth's internal structure layers (hidden initially)
            createEarthLayers();

            // Create two hemispheres (hidden initially)
            createHemispheres();

            // Create middle content area (hidden initially)
            createMiddleContent();

            // Add click event listener
            earthRenderer.domElement.addEventListener('click', onEarthClick);

            console.log('Earth 3D initialized successfully!');
        }

        // Create labels for cross-section layers
        function createEarthLayers() {
            if (!earthScene) return;

            // Layer data matching cross-section
            const layers = [
                {
                    radius: 0.15,
                    color: 0xFFD700,
                    emissive: 0xFFD700,
                    emissiveIntensity: 0.8,
                    name: 'NH√ÇN TRONG',
                    desc: 'R·∫Øn - S·∫Øt & Niken',
                    temp: '5000-6000¬∞C',
                    depth: '~1220 km b√°n k√≠nh'
                },
                {
                    radius: 0.35,
                    color: 0xFF4500,
                    emissive: 0xFF6347,
                    emissiveIntensity: 0.6,
                    name: 'NH√ÇN NGO√ÄI',
                    desc: 'L·ªèng - S·∫Øt n√≥ng ch·∫£y',
                    temp: '4000-5000¬∞C',
                    depth: '~2260 km ƒë·ªô d√†y'
                },
                {
                    radius: 0.85,
                    color: 0xFF6B35,
                    emissive: 0xFF8C00,
                    emissiveIntensity: 0.4,
                    name: 'MANTI',
                    desc: 'B√°n r·∫Øn - Magma',
                    temp: '1000-3700¬∞C',
                    depth: '~2900 km ƒë·ªô d√†y'
                },
                {
                    radius: 1.0,
                    color: 0x8B4513,
                    emissive: 0x654321,
                    emissiveIntensity: 0.2,
                    name: 'V·ªé TR√ÅI ƒê·∫§T',
                    desc: 'R·∫Øn - ƒê√° & ƒê·∫•t',
                    temp: '-50¬∞C ƒë·∫øn +50¬∞C',
                    depth: '5-70 km ƒë·ªô d√†y'
                }
            ];

            // NO LABELS - only clear boundaries between layers
            console.log(`‚úì Earth layers data loaded (boundaries will be drawn clearly)`);
        }

        // Create middle content - hi·ªÉn th·ªã th√¥ng tin c√°c l·ªõp ·ªü gi·ªØa
        function createMiddleContent() {
            if (middleContentGroup) {
                earthScene.remove(middleContentGroup);
            }

            middleContentGroup = new THREE.Group();
            middleContentGroup.visible = false;

            // Th√¥ng tin c√°c l·ªõp
            const layerInfo = [
                {
                    name: 'NH√ÇN TRONG',
                    desc: 'R·∫Øn - S·∫Øt & Niken',
                    temp: '5000-6000¬∞C',
                    color: 0xFFFF00,
                    yPos: 1.2
                },
                {
                    name: 'NH√ÇN NGO√ÄI',
                    desc: 'L·ªèng - S·∫Øt n√≥ng ch·∫£y',
                    temp: '4000-5000¬∞C',
                    color: 0xFF4400,
                    yPos: 0.4
                },
                {
                    name: 'MANTI',
                    desc: 'B√°n r·∫Øn - Magma',
                    temp: '1000-3700¬∞C',
                    color: 0xFF8844,
                    yPos: -0.4
                },
                {
                    name: 'V·ªé TR√ÅI ƒê·∫§T',
                    desc: 'R·∫Øn - ƒê√° & ƒê·∫•t',
                    temp: '-50¬∞C ƒë·∫øn +50¬∞C',
                    color: 0x8B4513,
                    yPos: -1.2
                }
            ];

            // T·∫°o label cho t·ª´ng l·ªõp
            layerInfo.forEach(info => {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 180;
                const ctx = canvas.getContext('2d');

                // Background v·ªõi vi·ªÅn m√†u layer
                ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const colorHex = '#' + info.color.toString(16).padStart(6, '0');
                ctx.strokeStyle = colorHex;
                ctx.lineWidth = 4;
                ctx.strokeRect(4, 4, canvas.width - 8, canvas.height - 8);

                // T√™n l·ªõp
                ctx.font = 'Bold 40px Arial';
                ctx.fillStyle = colorHex;
                ctx.textAlign = 'center';
                ctx.fillText(info.name, canvas.width / 2, 55);

                // M√¥ t·∫£
                ctx.font = '26px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(info.desc, canvas.width / 2, 100);

                // Nhi·ªát ƒë·ªô
                ctx.font = '24px Arial';
                ctx.fillStyle = '#ffaa00';
                ctx.fillText(info.temp, canvas.width / 2, 140);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    depthTest: false
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(2.0, 0.7, 1);
                sprite.position.set(0, info.yPos, 0); // ƒê·∫∑t ·ªü gi·ªØa (x = 0)

                middleContentGroup.add(sprite);
            });

            earthScene.add(middleContentGroup);
            console.log('‚úì Created middle content labels');
        }

        // Create two hemispheres with CROSS-SECTION showing internal layers
        function createHemispheres() {
            if (!earthScene) return;

            const textureLoader = new THREE.TextureLoader();

            // ============================================
            // LEFT HEMISPHERE with cross-section
            // ============================================
            leftHemisphere = new THREE.Group();
            leftHemisphere.visible = false;
            earthScene.add(leftHemisphere);

            // Outer shell (Earth surface)
            const leftShellGeometry = new THREE.SphereGeometry(1, 64, 64, 0, Math.PI);
            const leftShellMaterial = new THREE.MeshPhongMaterial({
                color: 0x2233ff,
                emissive: 0x112244,
                shininess: 5,
                side: THREE.FrontSide
            });
            const leftShell = new THREE.Mesh(leftShellGeometry, leftShellMaterial);
            leftHemisphere.add(leftShell);

            // Cross-section flat surface showing internal layers
            leftCrossSection = createCrossSection();
            leftCrossSection.rotation.y = Math.PI; // Face outward
            leftHemisphere.add(leftCrossSection);

            // ============================================
            // RIGHT HEMISPHERE with cross-section
            // ============================================
            rightHemisphere = new THREE.Group();
            rightHemisphere.visible = false;
            earthScene.add(rightHemisphere);

            // Outer shell (Earth surface)
            const rightShellGeometry = new THREE.SphereGeometry(1, 64, 64, Math.PI, Math.PI);
            const rightShellMaterial = new THREE.MeshPhongMaterial({
                color: 0x2233ff,
                emissive: 0x112244,
                shininess: 5,
                side: THREE.FrontSide
            });
            const rightShell = new THREE.Mesh(rightShellGeometry, rightShellMaterial);
            rightHemisphere.add(rightShell);

            // Cross-section flat surface
            rightCrossSection = createCrossSection();
            rightHemisphere.add(rightCrossSection);

            // Load Earth texture for both hemispheres
            textureLoader.load(
                'https://unpkg.com/three-globe@2.24.9/example/img/earth-blue-marble.jpg',
                function(texture) {
                    leftShellMaterial.map = texture;
                    leftShellMaterial.color = new THREE.Color(0xffffff);
                    leftShellMaterial.needsUpdate = true;

                    rightShellMaterial.map = texture;
                    rightShellMaterial.color = new THREE.Color(0xffffff);
                    rightShellMaterial.needsUpdate = true;

                    console.log('‚úì Hemisphere textures loaded');
                }
            );

            console.log('‚úì Created hemispheres with cross-sections');
        }

        // Create cross-section showing internal Earth layers as RINGS (ƒë·ªô d√†y r√µ r√†ng)
        function createCrossSection() {
            const crossSection = new THREE.Group();

            // Layer definitions - V·∫º T·ª™NG V√ÄNH RI√äNG BI·ªÜT
            const layers = [
                {
                    innerRadius: 0,
                    outerRadius: 0.15,
                    color: 0xFFFF00,      // V√ÄNG S√ÅNG - Nh√¢n Trong
                    emissive: 0xFFFF00,
                    emissiveIntensity: 1.2,
                    name: 'NH√ÇN TRONG (r·∫Øn)'
                },
                {
                    innerRadius: 0.15,
                    outerRadius: 0.35,
                    color: 0xFF4400,      // CAM ƒê·ªé - Nh√¢n Ngo√†i
                    emissive: 0xFF6600,
                    emissiveIntensity: 0.9,
                    name: 'NH√ÇN NGO√ÄI (l·ªèng)'
                },
                {
                    innerRadius: 0.35,
                    outerRadius: 0.85,
                    color: 0xFF8844,      // CAM - Manti
                    emissive: 0xFFAA00,
                    emissiveIntensity: 0.7,
                    name: 'MANTI (b√°n r·∫Øn)'
                },
                {
                    innerRadius: 0.85,
                    outerRadius: 1.0,
                    color: 0x8B4513,      // N√ÇU - V·ªè
                    emissive: 0x654321,
                    emissiveIntensity: 0.3,
                    name: 'V·ªé TR√ÅI ƒê·∫§T (r·∫Øn)'
                }
            ];

            // V·∫Ω t·ª´ng v√†nh (ring) cho m·ªói l·ªõp - R√ï R√ÄNG ƒê·ªò D√ÄY
            layers.forEach((layer, index) => {
                if (layer.innerRadius === 0) {
                    // Nh√¢n trong - d√πng Circle
                    const geometry = new THREE.CircleGeometry(layer.outerRadius, 256);
                    const material = new THREE.MeshPhongMaterial({
                        color: layer.color,
                        emissive: layer.emissive,
                        emissiveIntensity: layer.emissiveIntensity,
                        side: THREE.DoubleSide,
                        shininess: 60,
                        flatShading: false
                    });
                    const circle = new THREE.Mesh(geometry, material);
                    circle.userData.layerName = layer.name;
                    crossSection.add(circle);
                } else {
                    // C√°c l·ªõp kh√°c - d√πng Ring ƒë·ªÉ th·∫•y r√µ ƒë·ªô d√†y
                    const geometry = new THREE.RingGeometry(layer.innerRadius, layer.outerRadius, 256);
                    const material = new THREE.MeshPhongMaterial({
                        color: layer.color,
                        emissive: layer.emissive,
                        emissiveIntensity: layer.emissiveIntensity,
                        side: THREE.DoubleSide,
                        shininess: 60,
                        flatShading: false
                    });
                    const ring = new THREE.Mesh(geometry, material);
                    ring.userData.layerName = layer.name;
                    crossSection.add(ring);
                }

                // Th√™m ƒê∆Ø·ªúNG VI·ªÄN TR·∫ÆNG r√µ r√†ng gi·ªØa c√°c l·ªõp
                if (index < layers.length - 1) {
                    const boundaryGeometry = new THREE.RingGeometry(
                        layer.outerRadius - 0.005,
                        layer.outerRadius + 0.005,
                        256
                    );
                    const boundaryMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 1.0 // Ho√†n to√†n r√µ
                    });
                    const boundary = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
                    boundary.position.z = 0.001; // Slightly forward to prevent z-fighting
                    crossSection.add(boundary);
                }
            });

            crossSection.userData.isStaticCrossSection = true;
            return crossSection;
        }

        // Handle Earth click
        function onEarthClick(event) {
            if (!earthScene || !earthCamera || !earthRenderer) return;

            // Calculate mouse position in normalized device coordinates
            const rect = earthRenderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Update raycaster
            raycaster.setFromCamera(mouse, earthCamera);

            // Check intersection with Earth
            const intersects = raycaster.intersectObject(earthMesh);

            if (intersects.length > 0) {
                toggleSplit();
            }
        }

        // Toggle split/unsplit - C·∫ÆT ƒê√îI TR√ÅI ƒê·∫§T
        function toggleSplit() {
            isSplit = !isSplit;

            const btn = document.getElementById('splitToggleBtn');

            if (isSplit) {
                console.log('‚úÇÔ∏è Cutting Earth in half...');

                // Hide original earth and clouds
                earthMesh.visible = false;
                cloudsMesh.visible = false;

                // Show BOTH hemispheres with cross-sections
                leftHemisphere.visible = true;
                rightHemisphere.visible = true;

                // Reset positions and rotations for animation
                leftHemisphere.position.set(0, 0, 0);
                rightHemisphere.position.set(0, 0, 0);
                leftHemisphere.rotation.set(0, 0, 0);
                rightHemisphere.rotation.set(0, 0, 0);

                // Set initial cross-section rotations
                if (leftCrossSection) {
                    leftCrossSection.rotation.y = Math.PI;
                }
                if (rightCrossSection) {
                    rightCrossSection.rotation.y = 0;
                }

                // Note: Cross-sections are part of hemispheres, no separate layers needed
                // NO LABELS - only clear ring boundaries

                // Show middle content (labels ·ªü gi·ªØa)
                if (middleContentGroup) {
                    middleContentGroup.visible = true;
                }

                // Update button
                if (btn) {
                    btn.innerHTML = '‚ùå ƒê√≥ng C·∫•u Tr√∫c';
                    btn.classList.add('active');
                }

                // Adjust camera for better view of cross-section (zoom out ƒë·ªÉ th·∫•y c·∫£ 2 n·ª≠a)
                earthControls.autoRotate = false;
                earthControls.minDistance = 3;
                earthControls.maxDistance = 12; // TƒÉng l√™n ƒë·ªÉ th·∫•y kho·∫£ng tr·ªëng gi·ªØa

                console.log('‚úì Earth split showing cross-sections with internal layers');
            } else {
                console.log('üîí Closing Earth halves...');

                // Show original earth
                earthMesh.visible = true;
                cloudsMesh.visible = true;

                // Hide hemispheres
                leftHemisphere.visible = false;
                rightHemisphere.visible = false;

                // Hide middle content
                if (middleContentGroup) {
                    middleContentGroup.visible = false;
                }

                // Update button
                if (btn) {
                    btn.innerHTML = 'üåç Xem C·∫•u Tr√∫c B√™n Trong';
                    btn.classList.remove('active');
                }

                // Reset camera limits
                earthControls.minDistance = 1.5;
                earthControls.maxDistance = 5;
            }
        }


        // Initialize Day/Night 3D scene
        function initDayNight3D() {
            const container = document.getElementById('daynight-3d-container');
            if (!container) {
                console.error('Day/Night container not found!');
                return;
            }

            if (dayNightScene) {
                console.log('Day/Night scene already initialized');
                return;
            }

            console.log('Initializing Day/Night 3D...');

            // Clear container
            container.innerHTML = '';

            // Create scene
            dayNightScene = new THREE.Scene();
            dayNightScene.background = new THREE.Color(0x000000);

            // Create camera (positioned to see both Sun and Earth orbit)
            const aspect = container.clientWidth / container.clientHeight;
            dayNightCamera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            dayNightCamera.position.set(2, 6, 8); // Higher and further to see orbit
            dayNightCamera.lookAt(0, 0, 0);

            // Create renderer
            dayNightRenderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: false
            });
            dayNightRenderer.setSize(container.clientWidth, container.clientHeight);
            dayNightRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // ƒê·∫£m b·∫£o depth testing ƒë∆∞·ª£c b·∫≠t (m·∫∑c ƒë·ªãnh l√† true nh∆∞ng khai b√°o r√µ r√†ng)
            dayNightRenderer.sortObjects = true; // S·∫Øp x·∫øp ƒë·ªëi t∆∞·ª£ng theo kho·∫£ng c√°ch

            container.appendChild(dayNightRenderer.domElement);

            // Add ambient light (very dim)
            const ambientLight = new THREE.AmbientLight(0x222222, 0.2);
            dayNightScene.add(ambientLight);

            // Create Sun with ULTRA HIGH QUALITY texture like NASA (0, 0, 0)
            const sunGeometry = new THREE.SphereGeometry(0.8, 512, 512); // ULTRA ULTRA high resolution (n√©t h∆°n)

            // Load textures
            const textureLoader = new THREE.TextureLoader();

            // Create Sun with MeshStandardMaterial - M√ÄU TR·∫ÆNG V√ÄNG SANG TR·ªåNG
            const sunMaterial = new THREE.MeshStandardMaterial({
                color: 0xfff8e7, // M√†u tr·∫Øng v√†ng cam nh·∫°t gi·ªëng m·∫∑t tr·ªùi th·ª±c (d·ª±a tr√™n m√†u nhi·ªát ƒë·ªô 5800K)
                emissive: 0xffd700, // Emissive v√†ng nh·∫°t
                emissiveIntensity: 3.0, // TƒÉng c∆∞·ªùng ƒë·ªô s√°ng
                metalness: 0,
                roughness: 0.4, // Gi·∫£m roughness ƒë·ªÉ b√≥ng h∆°n, gi·ªëng plasma
                flatShading: false
            });
            sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.set(0, 0, 0);
            dayNightScene.add(sunMesh);

            // Load realistic Sun texture from NASA/ESA sources
            // S·ª≠ d·ª•ng texture m·∫∑t tr·ªùi th·ª±c t·∫ø t·ª´ ngu·ªìn c√¥ng khai (v√≠ d·ª•: SDO/NASA texture)
            textureLoader.load(
                'https://svs.gsfc.nasa.gov/vis/a000000/a004800/a004874/sdomap_4096.jpg', // High-res Sun texture from NASA SDO
                function(texture) {
                    console.log('Realistic Sun texture loaded!');
                    texture.anisotropy = dayNightRenderer.capabilities.getMaxAnisotropy();
                    texture.minFilter = THREE.LinearMipMapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    sunMaterial.map = texture;
                    sunMaterial.emissiveMap = texture;
                    sunMaterial.emissiveIntensity = 1.5;
                    sunMaterial.needsUpdate = true;
                },
                undefined,
                function(error) {
                    console.error('Error loading NASA Sun texture:', error);
                    // Fallback to procedural if NASA texture fails
                    createProceduralSunTexture();
                }
            );

            // Fallback procedural texture function (improved for realism)
            function createProceduralSunTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 4096; // Higher resolution for detail
                canvas.height = 4096;
                const ctx = canvas.getContext('2d');

                // Improved gradient for more realistic solar photosphere
                const gradient = ctx.createRadialGradient(2048, 2048, 0, 2048, 2048, 2048);
                gradient.addColorStop(0, '#fffbf0');    // Center: near-white hot core
                gradient.addColorStop(0.4, '#fff0c0');  // Mid: yellowish white
                gradient.addColorStop(0.7, '#ffe080');  // Outer: orange-yellow
                gradient.addColorStop(0.9, '#ffd040');  // Edge: deeper orange
                gradient.addColorStop(1, '#ffc000');    // Rim: bright orange

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 4096, 4096);

                // Add realistic solar granulation (plasma cells) - more detailed
                ctx.globalAlpha = 0.15;
                for (let i = 0; i < 1000; i++) { // More spots for detail
                    const x = Math.random() * 4096;
                    const y = Math.random() * 4096;
                    const radius = Math.random() * 60 + 20; // Larger granules
                    const brightness = Math.random() > 0.5 ? '#fff8e0' : '#ffcc80'; // Vary between bright and dark granules

                    const spotGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    spotGradient.addColorStop(0, brightness);
                    spotGradient.addColorStop(0.6, brightness + '88'); // Semi-transparent mid
                    spotGradient.addColorStop(1, 'transparent');

                    ctx.fillStyle = spotGradient;
                    ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
                }

                // Add subtle solar spots (sunspots) - dark regions
                ctx.globalAlpha = 0.25;
                for (let i = 0; i < 20; i++) { // Fewer but larger sunspots
                    const x = Math.random() * 4096;
                    const y = Math.random() * 4096;
                    const radius = Math.random() * 150 + 50;
                    const spotGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    spotGradient.addColorStop(0, '#8b4513'); // Dark brown center
                    spotGradient.addColorStop(0.5, '#cd853f'); // Umbra to penumbra
                    spotGradient.addColorStop(1, 'transparent');

                    ctx.fillStyle = spotGradient;
                    ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
                }

                // Apply texture
                const sunTexture = new THREE.CanvasTexture(canvas);
                sunTexture.anisotropy = dayNightRenderer.capabilities.getMaxAnisotropy();
                sunTexture.minFilter = THREE.LinearMipMapLinearFilter;
                sunTexture.magFilter = THREE.LinearFilter;
                sunTexture.wrapS = THREE.ClampToEdgeWrapping;
                sunTexture.wrapT = THREE.ClampToEdgeWrapping;

                sunMaterial.map = sunTexture;
                sunMaterial.emissiveMap = sunTexture;
                sunMaterial.needsUpdate = true;

                console.log('‚úì Fallback realistic procedural Sun created!');
            }

            // Add bump map for surface texture (using same texture for simplicity, or load separate)
            textureLoader.load(
                'https://svs.gsfc.nasa.gov/vis/a000000/a004800/a004874/sdomap_4096.jpg', // Reuse for bump
                function(bumpTexture) {
                    sunMaterial.bumpMap = bumpTexture;
                    sunMaterial.bumpScale = 0.02; // Subtle surface relief for plasma texture
                    sunMaterial.needsUpdate = true;
                }
            );

            // Sun light (from center) - M√ÄU TR·∫ÆNG V√ÄNG
            const sunLight = new THREE.PointLight(0xfff8e7, 3.0, 100); // M√†u g·∫ßn v·ªõi ph·ªï m·∫∑t tr·ªùi th·ª±c, s√°ng h∆°n
            sunLight.position.set(0, 0, 0);
            dayNightScene.add(sunLight);

            // Create ULTRA SMOOTH multi-layer glow - IMPROVED FOR CORONA REALISM
            const glowLayers = [
                // Inner chromosphere - reddish tint
                { radius: 1.02, color: 0xffd0d0, opacity: 0.25 },
                { radius: 1.05, color: 0xffe0c0, opacity: 0.20 },
                { radius: 1.10, color: 0xfff0e0, opacity: 0.18 },

                // Middle transition region
                { radius: 1.15, color: 0xffffe0, opacity: 0.15 },
                { radius: 1.25, color: 0xffffd0, opacity: 0.12 },
                { radius: 1.35, color: 0xffffc0, opacity: 0.10 },

                // Outer corona - whiter and fainter
                { radius: 1.50, color: 0xfffff0, opacity: 0.08 },
                { radius: 1.70, color: 0xffffff, opacity: 0.05 },
                { radius: 1.90, color: 0xffffff, opacity: 0.03 },
                { radius: 2.20, color: 0xffffff, opacity: 0.02 }
            ];

            // Create all glow layers with high resolution for smoothness
            glowLayers.forEach((layer, index) => {
                const glowGeometry = new THREE.SphereGeometry(layer.radius, 128, 128);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: layer.color,
                    transparent: true,
                    opacity: layer.opacity,
                    side: THREE.BackSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.position.set(0, 0, 0);
                dayNightScene.add(glowMesh);

                // Store for animation
                sunGlowLayers.push({
                    mesh: glowMesh,
                    baseOpacity: layer.opacity,
                    speed: 0.5 + index * 0.1, // Different animation speed for each layer
                    offset: index * 0.5 // Phase offset
                });
            });

            // Create orbit group for Earth (to orbit around Sun)
            earthOrbitGroup = new THREE.Group();
            dayNightScene.add(earthOrbitGroup);

            // Create Earth sphere (smaller than before, realistic size compared to Sun)
            const geometry = new THREE.SphereGeometry(0.4, 64, 64);

            // Start with basic material
            const material = new THREE.MeshPhongMaterial({
                color: 0x2233ff,
                emissive: 0x000000,
                shininess: 5,
                depthTest: true,    // ƒê·∫£m b·∫£o ki·ªÉm tra ƒë·ªô s√¢u
                depthWrite: true    // Ghi v√†o depth buffer
            });

            dayNightEarth = new THREE.Mesh(geometry, material);
            dayNightEarth.renderOrder = 0; // Render order m·∫∑c ƒë·ªãnh

            // Position Earth away from Sun (orbital distance)
            dayNightEarth.position.set(4, 0, 0);

            // Add Earth to orbit group
            earthOrbitGroup.add(dayNightEarth);

            // Load realistic Earth texture
            textureLoader.load(
                'https://unpkg.com/three-globe@2.24.9/example/img/earth-blue-marble.jpg',
                function(texture) {
                    console.log('Day/Night Earth texture loaded!');
                    dayNightEarth.material.map = texture;
                    dayNightEarth.material.color = new THREE.Color(0xffffff);
                    dayNightEarth.material.needsUpdate = true;
                },
                undefined,
                function(error) {
                    console.error('Error loading day/night earth texture:', error);
                }
            );

            // Add clouds layer
            const cloudsGeometry = new THREE.SphereGeometry(0.41, 64, 64);
            const cloudsMaterial = new THREE.MeshPhongMaterial({
                transparent: true,
                opacity: 0,
                depthWrite: false
            });

            dayNightClouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);

            // Position clouds at same location as Earth
            dayNightClouds.position.set(4, 0, 0);

            // Add clouds to orbit group
            earthOrbitGroup.add(dayNightClouds);

            // Load clouds texture
            textureLoader.load(
                'https://unpkg.com/three-globe@2.24.9/example/img/earth-topology.png',
                function(texture) {
                    console.log('Day/Night clouds texture loaded!');
                    dayNightClouds.material.map = texture;
                    dayNightClouds.material.opacity = 0.15;
                    dayNightClouds.material.needsUpdate = true;
                },
                undefined,
                function(error) {
                    console.error('Error loading day/night clouds texture:', error);
                }
            );

            // ============================================
            // T·∫†O M·∫∂T TRƒÇNG (MOON) - Quay quanh Tr√°i ƒê·∫•t
            // ============================================

            // Create Moon orbit group
            moonOrbitGroup = new THREE.Group();
            moonOrbitGroup.position.set(4, 0, 0); // ƒê·∫∂T ·ªû V·ªä TR√ç TR√ÅI ƒê·∫§T - QUAN TR·ªåNG!
            earthOrbitGroup.add(moonOrbitGroup); // Moon orbits around Earth

            // Create Moon
            const moonGeometry = new THREE.SphereGeometry(0.1, 64, 64); // Smaller than Earth
            const moonMaterial = new THREE.MeshPhongMaterial({
                color: 0xaaaaaa,
                emissive: 0x000000,
                shininess: 5,
                depthTest: true,    // ƒê·∫£m b·∫£o ki·ªÉm tra ƒë·ªô s√¢u
                depthWrite: true    // Ghi v√†o depth buffer ƒë·ªÉ che c√°c v·∫≠t ph√≠a sau
            });
            moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
            moonMesh.position.set(0.8, 0, 0); // Distance from Earth
            moonMesh.renderOrder = 0; // Render order m·∫∑c ƒë·ªãnh
            moonOrbitGroup.add(moonMesh);

            // Load realistic Moon texture
            textureLoader.load(
                'https://unpkg.com/three-globe@2.24.9/example/img/moon.jpg',
                function(texture) {
                    console.log('Moon texture loaded!');
                    texture.anisotropy = dayNightRenderer.capabilities.getMaxAnisotropy();
                    moonMesh.material.map = texture;
                    moonMesh.material.color = new THREE.Color(0xffffff);
                    moonMesh.material.needsUpdate = true;
                },
                undefined,
                function(error) {
                    console.log('Moon texture failed, trying alternate...');
                    textureLoader.load(
                        'https://raw.githubusercontent.com/turban/webgl-earth/master/images/moon_1024.jpg',
                        function(texture) {
                            console.log('Alternate moon texture loaded!');
                            moonMesh.material.map = texture;
                            moonMesh.material.color = new THREE.Color(0xffffff);
                            moonMesh.material.needsUpdate = true;
                        }
                    );
                }
            );

            // Create Moon orbit path (ƒë∆∞·ªùng tr√≤n quanh Tr√°i ƒê·∫•t)
            const moonOrbitRadius = 0.8;
            const moonOrbitGeometry = new THREE.RingGeometry(moonOrbitRadius - 0.01, moonOrbitRadius + 0.01, 128);
            const moonOrbitMaterial = new THREE.MeshBasicMaterial({
                color: 0x666666,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.25
            });
            const moonOrbitRing = new THREE.Mesh(moonOrbitGeometry, moonOrbitMaterial);
            moonOrbitRing.rotation.x = Math.PI / 2; // Make it horizontal
            moonOrbitGroup.add(moonOrbitRing); // Th√™m v√†o moonOrbitGroup thay v√¨ earthOrbitGroup

            // ============================================
            // V·ªÜ TINH NASA ƒê√É B·ªä X√ìA THEO Y√äU C·∫¶U
            // ============================================

            // Add stars background
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.7,
                sizeAttenuation: true
            });

            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position',
                new THREE.Float32BufferAttribute(starsVertices, 3)
            );

            const starField = new THREE.Points(starsGeometry, starsMaterial);
            dayNightScene.add(starField);

            // Add orbit path visualization (optional but helpful)
            const orbitRadius = 4;
            const orbitGeometry = new THREE.RingGeometry(orbitRadius - 0.02, orbitRadius + 0.02, 128);
            const orbitMaterial = new THREE.MeshBasicMaterial({
                color: 0x444444,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.3
            });
            const orbitRing = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbitRing.rotation.x = Math.PI / 2; // Make it horizontal
            dayNightScene.add(orbitRing);

            // Add orbit controls
            dayNightControls = new THREE.OrbitControls(dayNightCamera, dayNightRenderer.domElement);
            dayNightControls.enableDamping = true;
            dayNightControls.dampingFactor = 0.05;
            dayNightControls.minDistance = 3;
            dayNightControls.maxDistance = 15;
            dayNightControls.enablePan = false;

            // Animation loop
            function animateDayNight() {
                dayNightAnimationId = requestAnimationFrame(animateDayNight);

                // 1. TR√ÅI ƒê·∫§T T·ª∞ QUAY (rotation around own axis): CH·∫¨M H·ªöN
                if (dayNightEarth) {
                    dayNightEarth.rotation.y += 0.008; // Gi·∫£m t·ª´ 0.0525 xu·ªëng 0.008 (ch·∫≠m h∆°n ~6.5 l·∫ßn)
                }
                if (dayNightClouds) {
                    dayNightClouds.rotation.y += 0.009; // Clouds slightly faster
                }

                // 2. TR√ÅI ƒê·∫§T QUAY QUANH M·∫∂T TR·ªúI: CH·∫¨M H∆†N
                if (earthOrbitGroup) {
                    earthOrbitGroup.rotation.y += 0.003; // Gi·∫£m t·ª´ 0.0105 xu·ªëng 0.003 (ch·∫≠m h∆°n ~3.5 l·∫ßn)
                }

                // 3. M·∫∂T TRƒÇNG T·ª∞ QUAY V√Ä QUAY QUANH TR√ÅI ƒê·∫§T: CH·∫¨M H∆†N
                if (moonMesh) {
                    moonMesh.rotation.y += 0.008; // M·∫∑t TrƒÉng t·ª± quay ch·∫≠m h∆°n
                }
                if (moonOrbitGroup) {
                    moonOrbitGroup.rotation.y += 0.015; // Quay quanh Tr√°i ƒê·∫•t ch·∫≠m h∆°n
                }

                // 4. M·∫∂T TR·ªúI T·ª∞ QUAY: CH·∫¨M H∆†N (ch·ªâ quay khi ch∆∞a split)
                if (sunMesh && sunMesh.visible && !isSunSplit) {
                    sunMesh.rotation.y += 0.001; // Gi·∫£m t·ª´ 0.005 xu·ªëng 0.001 (ch·∫≠m h∆°n 5 l·∫ßn)
                }

                // 5. Animate sun split - t√°ch ƒë√¥i m·∫∑t tr·ªùi
                if (isSunSplit && leftSunHalf && rightSunHalf) {
                    const targetDistance = 2.5; // Kho·∫£ng c√°ch gi·ªØa 2 n·ª≠a

                    // Smooth animation
                    if (sunSplitProgress < 1) {
                        sunSplitProgress += 0.02;
                        if (sunSplitProgress > 1) sunSplitProgress = 1;
                    }

                    // Easing function
                    const easeProgress = sunSplitProgress < 0.5
                        ? 4 * sunSplitProgress * sunSplitProgress * sunSplitProgress
                        : 1 - Math.pow(-2 * sunSplitProgress + 2, 3) / 2;

                    // Move halves apart
                    leftSunHalf.position.x = -targetDistance * easeProgress;
                    rightSunHalf.position.x = targetDistance * easeProgress;
                } else if (!isSunSplit && leftSunHalf && rightSunHalf && sunSplitProgress > 0) {
                    // Animate back together
                    sunSplitProgress -= 0.02;
                    if (sunSplitProgress < 0) sunSplitProgress = 0;

                    const targetDistance = 2.5;
                    const easeProgress = sunSplitProgress < 0.5
                        ? 4 * sunSplitProgress * sunSplitProgress * sunSplitProgress
                        : 1 - Math.pow(-2 * sunSplitProgress + 2, 3) / 2;

                    leftSunHalf.position.x = -targetDistance * easeProgress;
                    rightSunHalf.position.x = targetDistance * easeProgress;
                }

                // 6. Animate ULTRA SMOOTH multi-layer glow (breathing effect) - CH·∫¨M H∆†N
                const time = Date.now() * 0.001;

                // Animate each glow layer with subtle breathing
                sunGlowLayers.forEach((layer, index) => {
                    // Subtle pulsating effect - different speed for each layer (CH·∫¨M H∆†N)
                    const pulse = Math.sin(time * layer.speed * 0.3 + layer.offset) * 0.03; // Gi·∫£m t·ªëc ƒë·ªô v√† bi√™n ƒë·ªô
                    layer.mesh.material.opacity = layer.baseOpacity * (1 + pulse);

                    // Very subtle scale variation for outer layers only (CH·∫¨M H∆†N)
                    if (index >= 6) { // ƒêi·ªÅu ch·ªânh v√¨ gi·ªù c√≥ √≠t layer h∆°n
                        const scaleVariation = 1 + Math.sin(time * 0.15 + layer.offset) * 0.01; // Ch·∫≠m h∆°n
                        layer.mesh.scale.set(scaleVariation, scaleVariation, scaleVariation);
                    }

                    // Slow rotation for corona effect (CH·∫¨M H∆†N)
                    if (index >= 3 && index < 9) { // ƒêi·ªÅu ch·ªânh cho s·ªë layer m·ªõi
                        layer.mesh.rotation.z += 0.0002 * (index - 2); // Gi·∫£m t·ªëc ƒë·ªô quay
                    }
                });

                dayNightControls.update();
                dayNightRenderer.render(dayNightScene, dayNightCamera);
            }
            animateDayNight();

            // Handle resize
            const resizeHandler = () => {
                if (container.style.display !== 'none' && dayNightRenderer) {
                    const width = container.clientWidth;
                    const height = container.clientHeight;

                    dayNightCamera.aspect = width / height;
                    dayNightCamera.updateProjectionMatrix();
                    dayNightRenderer.setSize(width, height);
                }
            };

            window.addEventListener('resize', resizeHandler);

            // Initialize raycaster and mouse for sun click detection
            sunRaycaster = new THREE.Raycaster();
            sunMouse = new THREE.Vector2();

            // Add click event listener to detect sun clicks
            dayNightRenderer.domElement.addEventListener('click', onSunClick);

            console.log('Day/Night 3D initialized successfully!');
        }

        // Handle sun click to split it
        function onSunClick(event) {
            if (!dayNightScene || !dayNightCamera || !dayNightRenderer || !sunMesh) return;

            // Calculate mouse position in normalized device coordinates
            const rect = dayNightRenderer.domElement.getBoundingClientRect();
            sunMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            sunMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Update raycaster
            sunRaycaster.setFromCamera(sunMouse, dayNightCamera);

            // Check intersection with Sun
            const intersects = sunRaycaster.intersectObject(sunMesh);

            if (intersects.length > 0) {
                toggleSunSplit();
            }
        }

        // Toggle sun split/unsplit
        function toggleSunSplit() {
            isSunSplit = !isSunSplit;

            if (isSunSplit) {
                console.log('‚úÇÔ∏è Splitting sun in half...');

                // Hide original sun
                sunMesh.visible = false;

                // Hide glow layers
                sunGlowLayers.forEach(layer => {
                    if (layer.mesh) layer.mesh.visible = false;
                });

                // Create two sun halves
                createSunHalves();

                console.log('‚úì Sun split!');
            } else {
                console.log('üîí Closing sun halves...');

                // Show original sun
                sunMesh.visible = true;

                // Show glow layers
                sunGlowLayers.forEach(layer => {
                    if (layer.mesh) layer.mesh.visible = true;
                });

                // Hide sun halves
                if (leftSunHalf) {
                    leftSunHalf.visible = false;
                }
                if (rightSunHalf) {
                    rightSunHalf.visible = false;
                }

                // Reset split progress
                sunSplitProgress = 0;

                console.log('‚úì Sun restored!');
            }
        }

        // Create two sun halves
        function createSunHalves() {
            if (!dayNightScene) return;

            // Create left half
            if (!leftSunHalf) {
                const leftGeometry = new THREE.SphereGeometry(0.8, 512, 512, 0, Math.PI);
                const leftMaterial = sunMesh.material.clone();
                leftSunHalf = new THREE.Mesh(leftGeometry, leftMaterial);
                leftSunHalf.position.copy(sunMesh.position);
                dayNightScene.add(leftSunHalf);
            }
            leftSunHalf.visible = true;
            leftSunHalf.position.set(0, 0, 0);

            // Create right half
            if (!rightSunHalf) {
                const rightGeometry = new THREE.SphereGeometry(0.8, 512, 512, Math.PI, Math.PI);
                const rightMaterial = sunMesh.material.clone();
                rightSunHalf = new THREE.Mesh(rightGeometry, rightMaterial);
                rightSunHalf.position.copy(sunMesh.position);
                dayNightScene.add(rightSunHalf);
            }
            rightSunHalf.visible = true;
            rightSunHalf.position.set(0, 0, 0);

            // Reset split progress for animation
            sunSplitProgress = 0;
        }

        // ·∫®n loading sau 2 gi√¢y khi trang load
        window.addEventListener('load', function() {
            const allowedScenes = ['ngaydem','cau-tao-loi','plate-tectonics','gio','cac-mua-trong-nam'];
            let initialScene = 'ngaydem';

            // Support deep-link: ?scene=... or #scene=...
            try {
                const params = new URLSearchParams(window.location.search);
                let deepScene = params.get('scene');
                if (!deepScene && window.location.hash) {
                    const hash = window.location.hash.replace('#','');
                    if (hash.startsWith('scene=')) {
                        deepScene = hash.split('=')[1];
                    }
                }
                if (deepScene) {
                    if (!allowedScenes.includes(deepScene)) {
                        console.warn('Unknown deep-link scene:', deepScene);
                    } else {
                        initialScene = deepScene;
                    }
                }
            } catch(e){ console.warn('Deep-link init skipped', e); }

            setTimeout(() => { changeScene(initialScene); }, 1200);

            console.log('Page loaded, initializing Earth 3D...');

            // SAFETY: Always hide loading after max 2 seconds no matter what
            setTimeout(function() {
                const loadingEl = document.getElementById('loading');
                if (loadingEl && loadingEl.classList.contains('show')) {
                    loadingEl.classList.remove('show');
                    console.log('Loading force-hidden after timeout!');
                }
            }, 2000);

            // Check if Three.js and OrbitControls are loaded
            function checkLibrariesLoaded() {
                if (typeof THREE === 'undefined') {
                    console.error('Three.js not loaded yet, retrying...');
                    setTimeout(checkLibrariesLoaded, 100);
                    return;
                }

                // OrbitControls might not be in THREE namespace in some versions
                // Just check if THREE is loaded, OrbitControls will be checked during initialization

                console.log('All libraries loaded! Initializing...');

                // Libraries are ready, initialize (only if container exists)
                try {
                    const earthContainer = document.getElementById('earth-3d-container');
                    if (earthContainer) {
                        initEarth3D();
                        console.log('Earth 3D initialized successfully!');
                    }
                } catch (error) {
                    console.error('Error initializing Earth 3D:', error);
                }

                // Hide loading after initialization
                setTimeout(function() {
                    const loadingEl = document.getElementById('loading');
                    if (loadingEl) {
                        loadingEl.classList.remove('show');
                        console.log('Loading hidden!');
                    }
                }, 800);
            }

            // Start checking
            setTimeout(checkLibrariesLoaded, 100);
        });

        // H√†m ƒë·ªïi c·∫£nh
        function scrollToVideoSection() {
            const videoSection = document.getElementById('video-section');
            if (videoSection) {
                videoSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function changeScene(sceneId) {
            const iframe = document.getElementById('polycam-frame');
            const loading = document.getElementById('loading');
            const titleText = document.getElementById('scene-title-text');
            const titleIcon = document.querySelector('#current-scene-title h3 i');
            const globeSection = document.getElementById('gio-trai-dat');
            const daynight3dContainer = document.getElementById('daynight-3d-container');

            // Hi·ªán loading
            loading.classList.add('show');

            // C·∫≠p nh·∫≠t n√∫t active
            document.querySelectorAll('.scene-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.querySelector(`[data-scene="${sceneId}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }

            // C·∫≠p nh·∫≠t ti√™u ƒë·ªÅ c·∫£nh hi·ªán t·∫°i
            const scene = scenes[sceneId];
            titleText.textContent = scene.title;
            titleIcon.className = `fas ${scene.icon}`;

            // Hide all containers first
            daynight3dContainer.style.display = 'none';
            iframe.style.display = 'none';

            const globeContainer = document.getElementById('globe-container');
            if (globeContainer) {
                globeContainer.style.display = 'none';
            }
            if (globeSection) {
                globeSection.style.display = 'none';
            }

            const seasons3dContainer = document.getElementById('seasons-3d-container');
            if (seasons3dContainer) {
                seasons3dContainer.style.display = 'none';
            }
            const seasonsInfo = document.getElementById('seasons-info');
            if (seasonsInfo) {
                seasonsInfo.style.display = 'none';
            }

            const structure3dContainer = document.getElementById('structure-3d-container');
            if (structure3dContainer) {
                structure3dContainer.style.display = 'none';
            }

            const plateTectonicsContainer = document.getElementById('plate-tectonics-container');
            if (plateTectonicsContainer) {
                plateTectonicsContainer.style.display = 'none';
            }

            // X·ª≠ l√Ω hi·ªÉn th·ªã n·ªôi dung d·ª±a tr√™n scene
            if (sceneId === 'ngaydem') {
                // Show Day/Night 3D scene
                daynight3dContainer.style.display = 'block';

                // Initialize if not already done
                if (!dayNightScene) {
                    initDayNight3D();
                }
            } else if (sceneId === 'gio') {
                // Show Time Zone Globe scene
                const globeContainer = document.getElementById('globe-container');
                if (globeContainer) {
                    globeContainer.style.display = 'block';
                }

                // Show info panel
                if (globeSection) {
                    globeSection.style.display = 'block';
                }

                // Initialize if not already done
                if (!timeZoneScene) {
                    // Small delay to ensure container is visible
                    setTimeout(() => {
                        initTimeZoneGlobe3D();
                    }, 100);
                }
            } else if (sceneId === 'cau-tao-loi') {
                // Show Earth Structure 3D scene
                console.log('üîÑ [Main] Switching to Earth Structure scene...');
                const structure3dContainer = document.getElementById('structure-3d-container');
                if (structure3dContainer) {
                    structure3dContainer.style.display = 'block';
                    console.log('‚úì [Main] Structure container displayed');
                    // Pro animation: subtle entrance
                    try {
                        if (window.gsap) {
                            gsap.fromTo(structure3dContainer, {opacity: 0, y: 20}, {opacity: 1, y: 0, duration: 0.6, ease: 'power2.out'});
                            const btns = structure3dContainer.querySelectorAll('.structure-controls .structure-control-btn');
                            gsap.fromTo(btns, {y: 18, opacity: 0}, {y: 0, opacity: 1, duration: 0.5, ease: 'power2.out', stagger: 0.08, delay: 0.15});
                            const labelsWrap = document.getElementById('structureLayerLabels');
                            if (labelsWrap) {
                                gsap.fromTo(labelsWrap, {opacity: 0}, {opacity: 1, duration: 0.5, ease: 'power2.out', delay: 0.25});
                            }
                        }
                    } catch(e) { console.warn('GSAP animation skipped', e); }
                }

                // Initialize if not already done
                if (typeof initEarthStructure3D === 'function') {
                    if (!window.structureSceneObj) {
                        console.log('üöÄ [Main] Initializing structure scene...');
                        setTimeout(() => {
                            initEarthStructure3D();
                        }, 100);
                    } else {
                        console.log('‚úì [Main] Structure scene already exists');
                    }
                } else {
                    console.error('‚ùå [Main] initEarthStructure3D function not found!');
                }
            } else if (sceneId === 'plate-tectonics') {
                // Show Plate Tectonics 2D scene
                console.log('üîÑ [Main] Switching to Plate Tectonics 2D scene...');
                const plateTectonicsContainer = document.getElementById('plate-tectonics-container');
                if (plateTectonicsContainer) {
                    plateTectonicsContainer.style.display = 'block';
                    console.log('‚úì [Main] Plate Tectonics container displayed');
                }

                // Initialize if not already done
                if (typeof initPlateTectonics2D === 'function') {
                    if (!window.plateTectonicsScene) {
                        console.log('üöÄ [Main] Initializing Plate Tectonics 2D scene...');
                        setTimeout(() => {
                            initPlateTectonics2D();
                        }, 100);
                    } else {
                        console.log('‚úì [Main] Plate Tectonics 2D scene already exists');
                    }
                } else {
                    console.error('‚ùå [Main] initPlateTectonics2D function not found!');
                }
            } else if (sceneId === 'cac-mua-trong-nam') {
                // Show Seasons 3D scene
                const seasons3dContainer = document.getElementById('seasons-3d-container');
                if (seasons3dContainer) {
                    seasons3dContainer.style.display = 'block';
                }

                // Show seasons info panel
                const seasonsInfo = document.getElementById('seasons-info');
                if (seasonsInfo) {
                    seasonsInfo.style.display = 'block';
                }

                // Initialize if not already done
                if (!seasonsScene) {
                    setTimeout(() => {
                        initSeasons3D();
                    }, 100);
                }
            } else {
                iframe.style.display = 'block';
                iframe.src = scene.url;
            }

            // ·∫®n loading sau 1 gi√¢y
            setTimeout(() => {
                loading.classList.remove('show');
            }, 1000);

            // Smooth scroll ƒë·∫øn viewer
            document.querySelector('.viewer-wrapper').scrollIntoView({
                behavior: 'smooth',
                block: 'center'
            });
        }
    </script>

    <!-- Globe Time Zone 3D Rendering -->
    <script>
        // ====== HI·ªÇN TH·ªä QU·∫¢ ƒê·ªäA C·∫¶U 3D C√ì M√öI GI·ªú ======
        // timeZoneScene variables already declared in main script block
        let timeLabels = []; // Store time zone labels
        let dateLineMaterial; // Material for International Date Line animation
        let dateLineLabels = []; // Labels for date line
        let lastUpdateSecond = -1; // Track last update time

        function initTimeZoneGlobe3D() {
            const container = document.getElementById('globe-container');
            if (!container) {
                console.error('Globe container not found!');
                return;
            }

            if (timeZoneScene) {
                console.log('Time Zone globe already initialized');
                return;
            }

            console.log('Initializing Time Zone Globe 3D...');

            // Clear container
            container.innerHTML = '';

            // Create scene
            timeZoneScene = new THREE.Scene();
            timeZoneScene.background = new THREE.Color(0x000000);

            // Create camera
            const aspect = container.clientWidth / container.clientHeight;
            timeZoneCamera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            timeZoneCamera.position.z = 6;

            // Create renderer
            timeZoneRenderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: false
            });
            timeZoneRenderer.setSize(container.clientWidth, container.clientHeight);
            timeZoneRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(timeZoneRenderer.domElement);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x222222, 0.5);
            timeZoneScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 3, 5);
            timeZoneScene.add(directionalLight);

            // Create Earth sphere with realistic textures
            const earthGeometry = new THREE.SphereGeometry(2, 64, 64);
            const textureLoader = new THREE.TextureLoader();

            const earthMaterial = new THREE.MeshPhongMaterial({
                color: 0x2233ff,
                emissive: 0x000000,
                shininess: 5
            });

            timeZoneEarth = new THREE.Mesh(earthGeometry, earthMaterial);
            timeZoneEarth.rotation.y = -Math.PI / 2; // Rotate -90 degrees to align with coordinate system
            timeZoneScene.add(timeZoneEarth);

            // Load realistic Earth texture
            textureLoader.load(
                'https://cdn.jsdelivr.net/gh/openscilab/earthtextures@main/2_no_clouds_4k.jpg',
                function(texture) {
                    console.log('Time Zone Earth texture loaded!');
                    texture.anisotropy = timeZoneRenderer.capabilities.getMaxAnisotropy();
                    timeZoneEarth.material.map = texture;
                    timeZoneEarth.material.color = new THREE.Color(0xffffff);
                    timeZoneEarth.material.needsUpdate = true;
                }
            );

            // Load bump map
            textureLoader.load(
                'https://cdn.jsdelivr.net/gh/openscilab/earthtextures@main/elev_bump_4k.jpg',
                function(bumpTexture) {
                    timeZoneEarth.material.bumpMap = bumpTexture;
                    timeZoneEarth.material.bumpScale = 0.05;
                    timeZoneEarth.material.needsUpdate = true;
                }
            );

            // Create dark side overlay for day/night visualization
            const darkMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.4,
                side: THREE.FrontSide
            });
            const darkSide = new THREE.Mesh(earthGeometry.clone(), darkMaterial);
            darkSide.rotation.y = -Math.PI / 2; // Rotate to match Earth
            timeZoneScene.add(darkSide);

            // Add meridian lines (longitude lines for time zones)
            for (let i = 0; i < 24; i++) {
                const angle = (i * 15 + 90) * (Math.PI / 180); // 15 degrees per time zone, adjusted for Three.js
                const points = [];
                for (let lat = -90; lat <= 90; lat += 5) {
                    const phi = (90 - lat) * (Math.PI / 180);
                    const theta = angle;
                    const x = 2.01 * Math.sin(phi) * Math.cos(theta);
                    const y = 2.01 * Math.cos(phi);
                    const z = -2.01 * Math.sin(phi) * Math.sin(theta); // Negative z for correct orientation
                    points.push(new THREE.Vector3(x, y, z));
                }
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: i === 0 ? 0xff0000 : 0x00ffff, // Red for Prime Meridian (GMT)
                    transparent: true,
                    opacity: i === 0 ? 0.9 : 0.3
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                timeZoneScene.add(line);
            }

            // Add equator line
            const equatorPoints = [];
            for (let lon = 0; lon <= 360; lon += 5) {
                const theta = lon * (Math.PI / 180);
                const x = 2.01 * Math.cos(theta);
                const y = 0;
                const z = -2.01 * Math.sin(theta); // Negative z for correct orientation
                equatorPoints.push(new THREE.Vector3(x, y, z));
            }
            const equatorGeometry = new THREE.BufferGeometry().setFromPoints(equatorPoints);
            const equatorMaterial = new THREE.LineBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.5
            });
            const equatorLine = new THREE.Line(equatorGeometry, equatorMaterial);
            timeZoneScene.add(equatorLine);

            // ============================================
            // ƒê∆Ø·ªúNG ƒê·ªîI NG√ÄY QU·ªêC T·∫æ (INTERNATIONAL DATE LINE) - 180¬∞
            // ============================================

            // Create the International Date Line at 180¬∞ longitude
            const dateLineAngle = (180 + 90) * (Math.PI / 180); // 180 degrees + 90 adjustment for Three.js
            const dateLinePoints = [];
            for (let lat = -90; lat <= 90; lat += 3) { // More points for smoother line
                const phi = (90 - lat) * (Math.PI / 180);
                const theta = dateLineAngle;
                const x = 2.02 * Math.sin(phi) * Math.cos(theta);
                const y = 2.02 * Math.cos(phi);
                const z = -2.02 * Math.sin(phi) * Math.sin(theta); // Negative z for correct orientation
                dateLinePoints.push(new THREE.Vector3(x, y, z));
            }

            const dateLineGeometry = new THREE.BufferGeometry().setFromPoints(dateLinePoints);
            dateLineMaterial = new THREE.LineBasicMaterial({
                color: 0xff00ff, // Magenta/Purple - very distinctive
                transparent: true,
                opacity: 0.95,
                linewidth: 3
            });
            const dateLine = new THREE.Line(dateLineGeometry, dateLineMaterial);
            timeZoneScene.add(dateLine);

            // Add glowing tube around date line for emphasis
            const tubeRadius = 0.015;
            const tubePath = new THREE.CatmullRomCurve3(dateLinePoints);
            const tubeGeometry = new THREE.TubeGeometry(tubePath, 100, tubeRadius, 8, false);
            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00ff,
                transparent: true,
                opacity: 0.6,
                emissive: 0xff00ff,
                emissiveIntensity: 1
            });
            const dateTube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            timeZoneScene.add(dateTube);

            // Add pulsating glow layers around the date line
            for (let i = 0; i < 3; i++) {
                const glowRadius = tubeRadius * (2 + i);
                const glowGeometry = new THREE.TubeGeometry(tubePath, 100, glowRadius, 8, false);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.15 / (i + 1),
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                timeZoneScene.add(glow);
            }

            // Add date labels on BOTH sides of the date line
            // Get current date
            const now = new Date();
            const utc = now.getTime() + (now.getTimezoneOffset() * 60000);

            // West side (GMT+12): Tomorrow (ahead)
            const westDate = new Date(utc + (3600000 * 12));
            const westDay = westDate.toLocaleDateString('vi-VN', { weekday: 'long', day: '2-digit', month: '2-digit', year: 'numeric' });

            // East side (GMT-12): Yesterday (behind)
            const eastDate = new Date(utc + (3600000 * -12));
            const eastDay = eastDate.toLocaleDateString('vi-VN', { weekday: 'long', day: '2-digit', month: '2-digit', year: 'numeric' });

            // Create label for WEST side (Tomorrow - left of line when viewing from front)
            const createDateLabel = (text, position, color) => {
                const canvas = document.createElement('canvas');
                canvas.width = 768;
                canvas.height = 256;
                const context = canvas.getContext('2d');

                // Background with glow
                context.fillStyle = 'rgba(0, 0, 0, 0.85)';
                context.fillRect(0, 0, canvas.width, canvas.height);

                // Border
                context.strokeStyle = color;
                context.lineWidth = 4;
                context.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);

                // Title
                context.font = 'Bold 48px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.fillText(position === 'west' ? 'PH√çA T√ÇY (NG√ÄY MAI)' : 'PH√çA ƒê√îNG (H√îM QUA)', canvas.width / 2, 60);

                // Date
                context.font = 'Bold 36px Arial';
                context.fillStyle = 'white';
                context.fillText(text, canvas.width / 2, 120);

                // Arrow
                context.font = 'Bold 64px Arial';
                context.fillText(position === 'west' ? '‚Üê' : '‚Üí', canvas.width / 2, 200);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);

                // Position on opposite sides of date line
                // Date line is at 180¬∞ longitude, which after rotation is at x = 0, z = -2.x
                // West side (ahead in time) should be to the left when viewing from front
                // East side (behind in time) should be to the right when viewing from front
                const offsetZ = position === 'west' ? 0.8 : -0.8;
                sprite.position.set(2.5, 0, offsetZ);
                sprite.scale.set(2, 0.65, 1);

                timeZoneScene.add(sprite);
                dateLineLabels.push({ sprite, position, text });

                return sprite;
            };

            createDateLabel(westDay, 'west', '#ff00ff');
            createDateLabel(eastDay, 'east', '#ff00ff');

            // Add special markers at key points on the date line
            const keyLatitudes = [
                { lat: 0, name: 'X√≠ch ƒë·∫°o' },
                { lat: 23.5, name: 'Ch√≠ tuy·∫øn B·∫Øc' },
                { lat: -23.5, name: 'Ch√≠ tuy·∫øn Nam' },
                { lat: 66.5, name: 'V√≤ng c·ª±c B·∫Øc' },
                { lat: -66.5, name: 'V√≤ng c·ª±c Nam' }
            ];

            keyLatitudes.forEach(point => {
                const phi = (90 - point.lat) * (Math.PI / 180);
                const theta = dateLineAngle;
                const x = 2.08 * Math.sin(phi) * Math.cos(theta);
                const y = 2.08 * Math.cos(phi);
                const z = -2.08 * Math.sin(phi) * Math.sin(theta); // Negative z for correct orientation

                // Create glowing marker
                const markerGeometry = new THREE.SphereGeometry(0.04, 16, 16);
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    emissive: 0xff00ff,
                    emissiveIntensity: 2
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(x, y, z);
                timeZoneScene.add(marker);

                // Add glow around marker
                const glowGeometry = new THREE.SphereGeometry(0.06, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.set(x, y, z);
                timeZoneScene.add(glow);
            });

            // Add major city markers with time zones
            const cities = [
                { name: 'Greenwich (GMT+0)', lat: 51.5, lon: 0, tz: 0 },
                { name: 'H√† N·ªôi (GMT+7)', lat: 21.0, lon: 105.8, tz: 7 },
                { name: 'Tokyo (GMT+9)', lat: 35.7, lon: 139.7, tz: 9 },
                { name: 'New York (GMT-5)', lat: 40.7, lon: -74.0, tz: -5 },
                { name: 'Los Angeles (GMT-8)', lat: 34.0, lon: -118.2, tz: -8 },
                { name: 'Sydney (GMT+10)', lat: -33.9, lon: 151.2, tz: 10 },
                { name: 'Paris (GMT+1)', lat: 48.9, lon: 2.3, tz: 1 },
                { name: 'Dubai (GMT+4)', lat: 25.3, lon: 55.3, tz: 4 },
                { name: 'Moscow (GMT+3)', lat: 55.8, lon: 37.6, tz: 3 },
                { name: 'Beijing (GMT+8)', lat: 39.9, lon: 116.4, tz: 8 }
            ];

            cities.forEach(city => {
                // Create marker point
                const phi = (90 - city.lat) * (Math.PI / 180);
                const theta = (city.lon + 90) * (Math.PI / 180); // Adjust for Three.js coordinate system
                const x = 2.05 * Math.sin(phi) * Math.cos(theta);
                const y = 2.05 * Math.cos(phi);
                const z = -2.05 * Math.sin(phi) * Math.sin(theta); // Negative z for correct orientation

                const markerGeometry = new THREE.SphereGeometry(0.03, 16, 16);
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff4444
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(x, y, z);
                timeZoneScene.add(marker);

                // Create sprite label
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 128;
                const context = canvas.getContext('2d');
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                context.font = 'Bold 36px Arial';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.fillText(city.name, canvas.width / 2, 50);

                // Add current time for this city
                const now = new Date();
                const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
                const cityTime = new Date(utc + (3600000 * city.tz));
                const timeStr = cityTime.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
                context.font = '28px Arial';
                context.fillStyle = '#ffff00';
                context.fillText(timeStr, canvas.width / 2, 90);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(x * 1.3, y * 1.3, z * 1.3);
                sprite.scale.set(1, 0.25, 1);
                timeZoneScene.add(sprite);

                timeLabels.push({ sprite, city });
            });

            // Add stars
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.7,
                sizeAttenuation: true
            });

            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position',
                new THREE.Float32BufferAttribute(starsVertices, 3)
            );

            const starField = new THREE.Points(starsGeometry, starsMaterial);
            timeZoneScene.add(starField);

            // Add orbit controls
            timeZoneControls = new THREE.OrbitControls(timeZoneCamera, timeZoneRenderer.domElement);
            timeZoneControls.enableDamping = true;
            timeZoneControls.dampingFactor = 0.05;
            timeZoneControls.minDistance = 3;
            timeZoneControls.maxDistance = 10;
            timeZoneControls.enablePan = false;

            // Animation loop
            function animateTimeZone() {
                timeZoneAnimationId = requestAnimationFrame(animateTimeZone);

                // Rotate Earth based on real time (to show day/night)
                const now = new Date();
                const seconds = now.getUTCHours() * 3600 + now.getUTCMinutes() * 60 + now.getUTCSeconds();
                timeZoneEarth.rotation.y = (seconds / 86400) * 2 * Math.PI;

                // ANIMATE INTERNATIONAL DATE LINE - Pulsating effect
                if (dateLineMaterial) {
                    const time = Date.now() * 0.001; // Convert to seconds
                    // Pulsating opacity
                    const pulse = Math.sin(time * 2) * 0.2 + 0.8; // Oscillate between 0.6 and 1.0
                    dateLineMaterial.opacity = pulse;
                }

                // Update time labels every second
                const currentSecond = Math.floor(now.getTime() / 1000);
                if (currentSecond !== lastUpdateSecond) {
                    lastUpdateSecond = currentSecond;
                    updateTimeLabels();
                }

                timeZoneControls.update();
                timeZoneRenderer.render(timeZoneScene, timeZoneCamera);
            }
            animateTimeZone();

            // Handle resize
            const resizeHandler = () => {
                if (container.style.display !== 'none' && timeZoneRenderer) {
                    const width = container.clientWidth;
                    const height = container.clientHeight;

                    timeZoneCamera.aspect = width / height;
                    timeZoneCamera.updateProjectionMatrix();
                    timeZoneRenderer.setSize(width, height);
                }
            };

            window.addEventListener('resize', resizeHandler);

            console.log('Time Zone Globe 3D initialized successfully!');
        }

        // Update time labels
        function updateTimeLabels() {
            timeLabels.forEach(({ sprite, city }) => {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 128;
                const context = canvas.getContext('2d');
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                context.font = 'Bold 36px Arial';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.fillText(city.name, canvas.width / 2, 50);

                const now = new Date();
                const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
                const cityTime = new Date(utc + (3600000 * city.tz));
                const timeStr = cityTime.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                context.font = '28px Arial';
                context.fillStyle = '#ffff00';
                context.fillText(timeStr, canvas.width / 2, 90);

                const texture = new THREE.CanvasTexture(canvas);
                sprite.material.map = texture;
                sprite.material.needsUpdate = true;
            });
        }

        // ============================================
        // SEASONS 3D - C√ÅC M√ôA TRONG NƒÇM
        // ============================================

        // seasonsScene variables already declared in main script block
        let currentSeason = 'spring';
        let autoRotate = false;
        let currentAngle = 0; // Current angle of Earth on orbit
        let targetAngle = 0; // Target angle for transitions
        let orbitSpeed = 0.002; // Speed of orbit animation

        // 4 v·ªã tr√≠ c·ªßa Tr√°i ƒê·∫•t trong nƒÉm (tr√™n qu·ªπ ƒë·∫°o elip)
        const seasonPositions = {
            spring: { angle: 0, date: '21/03 - Xu√¢n Ph√¢n', description: 'M·∫∑t Tr·ªùi chi·∫øu vu√¥ng g√≥c x√≠ch ƒë·∫°o', temp: '√în h√≤a', color: '#00ff00', emoji: 'üå∏' },
            summer: { angle: Math.PI / 2, date: '21/06 - H·∫° Ch√≠', description: 'B·∫Øc b√°n c·∫ßu nghi√™ng v·ªÅ M·∫∑t Tr·ªùi', temp: 'N√≥ng (B·∫Øc), L·∫°nh (Nam)', color: '#ff0000', emoji: '‚òÄÔ∏è' },
            autumn: { angle: Math.PI, date: '23/09 - Thu Ph√¢n', description: 'M·∫∑t Tr·ªùi l·∫°i chi·∫øu vu√¥ng g√≥c x√≠ch ƒë·∫°o', temp: '√în h√≤a', color: '#ff8800', emoji: 'üçÇ' },
            winter: { angle: -Math.PI / 2, date: '22/12 - ƒê√¥ng Ch√≠', description: 'Nam b√°n c·∫ßu nghi√™ng v·ªÅ M·∫∑t Tr·ªùi', temp: 'L·∫°nh (B·∫Øc), N√≥ng (Nam)', color: '#0088ff', emoji: '‚ùÑÔ∏è' }
        };

        let earthGroup, seasonEarthMesh, earthLabel, sun; // Single Earth instance that moves

        function initSeasons3D() {
            const container = document.getElementById('seasons-3d-container');
            if (!container) {
                console.error('Seasons container not found!');
                return;
            }

            if (seasonsScene) {
                console.log('Seasons scene already initialized');
                return;
            }

            console.log('Initializing Seasons 3D...');

            // Clear container (except controls)
            const controls = container.querySelector('.season-controls');
            container.innerHTML = '';
            if (controls) {
                container.appendChild(controls);
            }

            // Create scene
            seasonsScene = new THREE.Scene();
            seasonsScene.background = new THREE.Color(0x000000);

            // Create camera
            const aspect = container.clientWidth / container.clientHeight;
            seasonsCamera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            seasonsCamera.position.set(0, 8, 12);
            seasonsCamera.lookAt(0, 0, 0);

            // Create renderer
            seasonsRenderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: false
            });
            seasonsRenderer.setSize(container.clientWidth, container.clientHeight);
            seasonsRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.insertBefore(seasonsRenderer.domElement, container.firstChild);

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x222222, 0.3);
            seasonsScene.add(ambientLight);

            // Create SUN at center
            const textureLoader = new THREE.TextureLoader();
            const sunGeometry = new THREE.SphereGeometry(1, 64, 64);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xfff8e7,
                emissive: 0xffd700,
                emissiveIntensity: 2
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            seasonsScene.add(sun);

            // Sun light
            const sunLight = new THREE.PointLight(0xfff8e7, 2, 100);
            sunLight.position.set(0, 0, 0);
            seasonsScene.add(sunLight);

            // Sun glow
            for (let i = 0; i < 3; i++) {
                const glowGeometry = new THREE.SphereGeometry(1.1 + i * 0.1, 32, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffd700,
                    transparent: true,
                    opacity: 0.15 / (i + 1),
                    side: THREE.BackSide,
                    blending: THREE.AdditiveBlending
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                seasonsScene.add(glow);
            }

            // ============================================
            // CREATE SINGLE MOVING EARTH
            // ============================================
            const orbitRadius = 5;
            earthGroup = new THREE.Group();

            // Apply 23.5¬∞ tilt
            const axialTilt = (23.5 * Math.PI) / 180;
            earthGroup.rotation.z = axialTilt;

            // Earth sphere
            const earthGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const earthMaterial = new THREE.MeshPhongMaterial({
                color: 0x2244ff,
                emissive: 0x000000,
                shininess: 5
            });
            seasonEarthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
            earthGroup.add(seasonEarthMesh);

            // Load texture
            textureLoader.load(
                'https://unpkg.com/three-globe@2.24.9/example/img/earth-blue-marble.jpg',
                function(texture) {
                    earthMaterial.map = texture;
                    earthMaterial.color = new THREE.Color(0xffffff);
                    earthMaterial.needsUpdate = true;
                }
            );

            // Add axis line to show tilt
            const axisGeometry = new THREE.CylinderGeometry(0.015, 0.015, 1.5, 8);
            const axisMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const axis = new THREE.Mesh(axisGeometry, axisMaterial);
            axis.rotation.x = Math.PI / 2;
            earthGroup.add(axis);

            // Dynamic Earth label (will update as Earth moves)
            earthLabel = createSeasonLabel(seasonPositions['spring']);
            earthGroup.add(earthLabel);

            // Position Earth at starting angle
            updateEarthPosition();
            seasonsScene.add(earthGroup);

            // ============================================
            // CREATE 4 STATIC MARKERS AT SEASON POSITIONS
            // ============================================
            Object.keys(seasonPositions).forEach((season, index) => {
                const pos = seasonPositions[season];
                const x = orbitRadius * Math.cos(pos.angle);
                const z = orbitRadius * Math.sin(pos.angle);

                // Marker sphere
                const markerGeometry = new THREE.SphereGeometry(0.12, 16, 16);
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: pos.color,
                    emissive: pos.color,
                    emissiveIntensity: 1
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(x, 0, z);
                seasonsScene.add(marker);

                // Marker glow
                const glowGeometry = new THREE.SphereGeometry(0.18, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: pos.color,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.set(x, 0, z);
                seasonsScene.add(glow);

                // Static label at marker position
                const staticLabel = createStaticMarkerLabel(pos, season);
                staticLabel.position.set(x, 1.2, z);
                seasonsScene.add(staticLabel);
            });

            // Orbit path
            const orbitGeometry = new THREE.RingGeometry(4.9, 5.1, 128);
            const orbitMaterial = new THREE.MeshBasicMaterial({
                color: 0x444444,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.3
            });
            const orbitRing = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbitRing.rotation.x = Math.PI / 2;
            seasonsScene.add(orbitRing);

            // Stars
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.7
            });
            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            seasonsScene.add(starField);

            // Controls
            seasonsControls = new THREE.OrbitControls(seasonsCamera, seasonsRenderer.domElement);
            seasonsControls.enableDamping = true;
            seasonsControls.dampingFactor = 0.05;
            seasonsControls.minDistance = 5;
            seasonsControls.maxDistance = 20;
            seasonsControls.enablePan = false;

            // Animation
            function animateSeasons() {
                seasonsAnimationId = requestAnimationFrame(animateSeasons);

                // Rotate sun
                sun.rotation.y += 0.001;

                // Rotate Earth on its axis
                if (seasonEarthMesh) {
                    seasonEarthMesh.rotation.y += 0.005;
                }

                // Move Earth around Sun
                if (autoRotate) {
                    currentAngle += orbitSpeed;
                    if (currentAngle > Math.PI * 2) {
                        currentAngle -= Math.PI * 2;
                    }
                    updateEarthPosition();
                    detectAndUpdateSeason();
                } else {
                    // Smooth transition to target angle
                    const diff = targetAngle - currentAngle;
                    if (Math.abs(diff) > 0.01) {
                        currentAngle += diff * 0.05;
                        updateEarthPosition();
                    }
                }

                seasonsControls.update();
                seasonsRenderer.render(seasonsScene, seasonsCamera);
            }
            animateSeasons();

            // Resize handler
            const resizeHandler = () => {
                if (container.style.display !== 'none' && seasonsRenderer) {
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    seasonsCamera.aspect = width / height;
                    seasonsCamera.updateProjectionMatrix();
                    seasonsRenderer.setSize(width, height);
                }
            };
            window.addEventListener('resize', resizeHandler);

            console.log('Seasons 3D initialized successfully!');
        }

        // ============================================
        // HELPER FUNCTIONS
        // ============================================

        // Create dynamic label for moving Earth
        function createSeasonLabel(pos) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = pos.color;
            ctx.lineWidth = 4;
            ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);

            ctx.font = 'Bold 48px Arial';
            ctx.fillStyle = pos.color;
            ctx.textAlign = 'center';
            ctx.fillText(pos.emoji + ' ' + pos.date, canvas.width / 2, 60);

            ctx.font = '28px Arial';
            ctx.fillStyle = 'white';
            ctx.fillText(pos.description, canvas.width / 2, 110);

            ctx.font = 'Bold 32px Arial';
            ctx.fillStyle = '#ffff00';
            ctx.fillText(pos.temp, canvas.width / 2, 160);

            const labelTexture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: labelTexture });
            const label = new THREE.Sprite(labelMaterial);
            label.position.set(0, 1.5, 0);
            label.scale.set(2, 1, 1);
            return label;
        }

        // Create static marker labels
        function createStaticMarkerLabel(pos, season) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = pos.color;
            ctx.lineWidth = 3;
            ctx.strokeRect(3, 3, canvas.width - 6, canvas.height - 6);

            ctx.font = 'Bold 36px Arial';
            ctx.fillStyle = pos.color;
            ctx.textAlign = 'center';
            ctx.fillText(pos.emoji, canvas.width / 2, 50);

            ctx.font = 'Bold 28px Arial';
            ctx.fillStyle = 'white';
            ctx.fillText(pos.date.split(' - ')[0], canvas.width / 2, 95);

            const labelTexture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: labelTexture });
            const label = new THREE.Sprite(labelMaterial);
            label.scale.set(1.2, 0.6, 1);
            return label;
        }

        // Update Earth position based on current angle
        function updateEarthPosition() {
            if (!earthGroup) return;
            const orbitRadius = 5;
            const x = orbitRadius * Math.cos(currentAngle);
            const z = orbitRadius * Math.sin(currentAngle);
            earthGroup.position.set(x, 0, z);
        }

        // Detect current season based on angle and update label
        function detectAndUpdateSeason() {
            // Normalize angle to 0-2œÄ
            let normalizedAngle = currentAngle;
            while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
            while (normalizedAngle > Math.PI * 2) normalizedAngle -= Math.PI * 2;

            // Find closest season
            let closestSeason = 'spring';
            let minDiff = Math.PI * 2;

            Object.keys(seasonPositions).forEach(season => {
                let seasonAngle = seasonPositions[season].angle;
                // Normalize season angle
                while (seasonAngle < 0) seasonAngle += Math.PI * 2;

                let diff = Math.abs(normalizedAngle - seasonAngle);
                // Handle wrap-around
                if (diff > Math.PI) diff = Math.PI * 2 - diff;

                if (diff < minDiff) {
                    minDiff = diff;
                    closestSeason = season;
                }
            });

            // Only update if Earth is VERY CLOSE to the marker (within ~10 degrees = 0.175 radians)
            // This prevents premature color/label changes
            const threshold = 0.175; // approximately 10 degrees (very strict)
            
            if (minDiff < threshold && closestSeason !== currentSeason) {
                currentSeason = closestSeason;
                updateSeasonLabel(seasonPositions[closestSeason]);

                // Update button states
                document.querySelectorAll('.season-btn-control[data-season]').forEach(btn => {
                    btn.classList.remove('active');
                });
                const activeBtn = document.querySelector(`.season-btn-control[data-season="${closestSeason}"]`);
                if (activeBtn) {
                    activeBtn.classList.add('active');
                }
            }
        }

        // Update the Earth's label
        function updateSeasonLabel(pos) {
            if (!earthLabel || !earthGroup) return;

            // Remove old label
            earthGroup.remove(earthLabel);

            // Create new label
            earthLabel = createSeasonLabel(pos);
            earthGroup.add(earthLabel);
        }

        // Change season function
        function changeSeason(season) {
            // Stop auto rotation when manually selecting
            if (autoRotate) {
                toggleSeasonAnimation();
            }

            currentSeason = season;
            targetAngle = seasonPositions[season].angle;

            // Update button states
            document.querySelectorAll('.season-btn-control[data-season]').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.querySelector(`.season-btn-control[data-season="${season}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }

            // Update label immediately when manually selected
            // This ensures the label changes right away when user clicks a season button
            updateSeasonLabel(seasonPositions[season]);
        }

        // Toggle auto animation
        function toggleSeasonAnimation() {
            autoRotate = !autoRotate;
            const btn = document.getElementById('animToggle');
            btn.textContent = autoRotate ? '‚è∏Ô∏è D·ª´ng' : '‚ñ∂Ô∏è T·ª± ƒê·ªông';
            btn.classList.toggle('active', autoRotate);

            // Animation loop will handle the rotation automatically
            // No need for interval - Earth will continuously orbit
        }

        // ============================================
        // EARTH STRUCTURE 3D - L·ªöP V·ªé L√ïI
        // ============================================

        function initEarthStructure3D() {
            const container = document.getElementById('structure-3d-container');
            const mount = document.getElementById('structureCanvasMount');
            if (!container || !mount) {
                console.error('Structure container not found!');
                return;
            }

            if (structureSceneObj) {
                console.log('Structure scene already initialized');
                return;
            }

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x02040a);

            const camera = new THREE.PerspectiveCamera(
                45,
                container.clientWidth / container.clientHeight,
                0.1,
                100
            );
            camera.position.set(0, 1.5, 4.5);

            const renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            mount.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.minDistance = 2;
            controls.maxDistance = 9;

            // Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x020412, 0.6);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(5, 4, 4);
            dirLight.castShadow = false;
            scene.add(dirLight);

            const rimLight = new THREE.PointLight(0x5c8dff, 0.5);
            rimLight.position.set(-4, -3, -5);
            scene.add(rimLight);

            structureSceneObj = {
                scene,
                camera,
                renderer,
                controls,
                container,
                mount,
                layers: [],
                layerMeta: {},
                interactiveMeshes: [],
                isSplit: false,
                raycaster: new THREE.Raycaster(),
                pointer: new THREE.Vector2(),
                autoRotateInternal: true,
                labelElements: [],
                animationId: null,
                activeLayerKey: null,
                layerAutoRotateActive: false
            };
            window.structureSceneObj = structureSceneObj;

            loadStructureTextures()
                .then(textures => {
                    structureSceneObj.textures = textures;
                    buildStructureModel(textures);
                    bindStructureUI();
                    bindStructureInteractions();
                    startStructureLoop();
                    setupStructureResize();
                })
                .catch(err => {
                    console.error('Failed to load Earth structure textures', err);
                    const fallbackTextures = createFallbackTextureSet();
                    structureSceneObj.textures = fallbackTextures;
                    buildStructureModel(fallbackTextures);
                    bindStructureUI();
                    bindStructureInteractions();
                    startStructureLoop();
                    setupStructureResize();
                });
        }

        function loadStructureTextures() {
            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous');
            const entries = Object.entries(STRUCTURE_TEXTURE_URLS);

            return Promise.all(entries.map(([key, url]) => {
                return new Promise(resolve => {
                    loader.load(
                        url,
                        texture => {
                            if (key === 'day' || key === 'night' || key === 'clouds') {
                                texture.encoding = THREE.sRGBEncoding;
                            } else {
                                texture.encoding = THREE.LinearEncoding;
                            }
                            resolve({ key, texture });
                        },
                        undefined,
                        () => resolve({ key, texture: createFallbackTexture(key) })
                    );
                });
            })).then(results => {
                const textures = {};
                results.forEach(({ key, texture }) => {
                    textures[key] = texture || createFallbackTexture(key);
                });
                return textures;
            });
        }

        function createFallbackTextureSet() {
            const textures = {};
            Object.keys(STRUCTURE_TEXTURE_URLS).forEach(key => {
                textures[key] = createFallbackTexture(key);
            });
            return textures;
        }

        function createFallbackTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 4;
            canvas.height = 4;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = STRUCTURE_FALLBACK_COLORS[type] || '#444';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const texture = new THREE.CanvasTexture(canvas);
            texture.encoding = (type === 'day' || type === 'night' || type === 'clouds') ? THREE.sRGBEncoding : THREE.LinearEncoding;
            texture.needsUpdate = true;
            return texture;
        }

        function buildStructureModel(textures) {
            if (!structureSceneObj) return;
            const state = structureSceneObj;
            const planetGroup = new THREE.Group();
            state.scene.add(planetGroup);
            state.planetGroup = planetGroup;

            // Crust (realistic Earth)
            textures.day.wrapS = textures.day.wrapT = THREE.ClampToEdgeWrapping;
            const crustGeometry = new THREE.SphereGeometry(1, 256, 256);
            const crustMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0x000000,
                shininess: 5,
                map: textures.day,
                bumpMap: textures.bump,
                bumpScale: 0.02,
                specularMap: textures.specular,
                specular: new THREE.Color(0x333333)
            });

            const crustMesh = new THREE.Mesh(crustGeometry, crustMaterial);
            crustMesh.name = 'V·ªè Tr√°i ƒê·∫•t';

            const crustGroup = new THREE.Group();
            crustGroup.add(crustMesh);

            // Clouds
            const cloudsGeometry = new THREE.SphereGeometry(1.01, 128, 128);
            const cloudsMaterial = new THREE.MeshPhongMaterial({
                map: textures.clouds,
                transparent: true,
                opacity: 0.15,
                depthWrite: false
            });
            const cloudsMesh = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
            crustGroup.add(cloudsMesh);

            planetGroup.add(crustGroup);

            state.cloudsMesh = cloudsMesh;
            state.crustGroup = crustGroup;

            function createLayerMaterial(baseColor, highlightColor, emissiveColor) {
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 1024;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createRadialGradient(512, 512, 0, 512, 512, 512);
                gradient.addColorStop(0, highlightColor);
                gradient.addColorStop(0.7, baseColor);
                gradient.addColorStop(1, '#1b1b1b');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const texture = new THREE.CanvasTexture(canvas);
                texture.encoding = THREE.sRGBEncoding;
                return new THREE.MeshPhysicalMaterial({
                    map: texture,
                    color: new THREE.Color(baseColor),
                    emissive: new THREE.Color(emissiveColor),
                    emissiveIntensity: 0.4,
                    metalness: 0.55,
                    roughness: 0.3,
                    clearcoat: 0.9,
                    clearcoatRoughness: 0.1
                });
            }

            function addGlowShell(radius, color) {
                const geometry = new THREE.SphereGeometry(radius * 1.03, 64, 64);
                const material = new THREE.MeshBasicMaterial({
                    color,
                    transparent: true,
                    opacity: 0.35,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });
                const glowMesh = new THREE.Mesh(geometry, material);
                planetGroup.add(glowMesh);
                return glowMesh;
            }

            // T√≠nh to√°n kho·∫£ng c√°ch t√°ch l·ªõp chuy√™n nghi·ªáp
            // M·ªói l·ªõp c·∫ßn kho·∫£ng c√°ch ƒë·ªß l·ªõn ƒë·ªÉ kh√¥ng d√≠nh v√†o nhau khi t√°ch
            // Padding gi·ªØa c√°c l·ªõp = ƒë∆∞·ªùng k√≠nh l·ªõp l·ªõn nh·∫•t + th√™m kho·∫£ng tr·ªëng
            const maxDiameter = 1.0 * 2; // V·ªè Tr√°i ƒê·∫•t c√≥ b√°n k√≠nh l·ªõn nh·∫•t = 1.0
            const padding = maxDiameter + 3.5; // Kho·∫£ng c√°ch padding l·ªõn ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng d√≠nh
            
            // T√≠nh to√°n v·ªã tr√≠ t√°ch t·ª´ tr√°i sang ph·∫£i, cƒÉn gi·ªØa
            const layerOrder = [
                { key: 'inner', radius: 0.2 },
                { key: 'outer', radius: 0.55 },
                { key: 'mantle', radius: 0.95 },
                { key: 'crust', radius: 1.0 }
            ];
            
            // T√≠nh t·ªïng chi·ªÅu r·ªông c·∫ßn thi·∫øt
            let totalWidth = 0;
            layerOrder.forEach((layer, index) => {
                totalWidth += layer.radius * 2; // ƒê∆∞·ªùng k√≠nh
                if (index < layerOrder.length - 1) {
                    totalWidth += padding; // Padding gi·ªØa c√°c l·ªõp
                }
            });
            
            // B·∫Øt ƒë·∫ßu t·ª´ b√™n tr√°i (√¢m)
            let currentX = -totalWidth / 2;
            const splitSpacing = {};
            
            layerOrder.forEach((layer, index) => {
                splitSpacing[layer.key] = currentX + layer.radius; // ƒê·∫∑t t√¢m l·ªõp ·ªü ƒë√¢y
                currentX += layer.radius * 2 + padding; // Di chuy·ªÉn sang l·ªõp ti·∫øp theo
            });

            const layerData = [
                {
                    key: 'inner',
                    label: 'L√µi Trong',
                    radius: 0.2,
                    splitX: splitSpacing.inner,
                    emoji: 'üî•',
                    material: createLayerMaterial('#ffd166', '#fff6b7', '#ff8c00'),
                    glowColor: null
                },
                {
                    key: 'outer',
                    label: 'L√µi Ngo√†i',
                    radius: 0.55,
                    splitX: splitSpacing.outer,
                    emoji: 'üåã',
                    material: createLayerMaterial('#ff7043', '#ffd1b5', '#ff7043'),
                    glowColor: null
                },
                {
                    key: 'mantle',
                    label: 'Manti',
                    radius: 0.95,
                    splitX: splitSpacing.mantle,
                    emoji: 'üåó',
                    material: createLayerMaterial('#ff8c42', '#ffd89c', '#ff6d00'),
                    glowColor: null
                }
            ];

            state.layers = [];
            state.glowShells = [];

            layerData.forEach(data => {
                const geometry = new THREE.SphereGeometry(data.radius, 160, 160);
                const material = data.material || new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0x000000
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = data.label;
                mesh.userData.layerKey = data.key;

                const group = new THREE.Group();
                group.add(mesh);
                if (data.glowColor) {
                    const glow = addGlowShell(data.radius, data.glowColor);
                    state.glowShells.push(glow);
                }
                planetGroup.add(group);

                state.layers.push({
                    key: data.key,
                    group,
                    homeX: 0,
                    splitX: data.splitX,
                    label: data.label,
                    emoji: data.emoji
                });
                state.layerMeta[data.key] = {
                    key: data.key,
                    label: data.label,
                    emoji: data.emoji,
                    group,
                    mesh
                };
                state.interactiveMeshes.push(mesh);
            });

            // Add crust layer definition at the end
            state.layers.push({
                key: 'crust',
                group: crustGroup,
                homeX: 0,
                splitX: splitSpacing.crust,
                label: 'V·ªè Tr√°i ƒê·∫•t',
                emoji: 'üåç'
            });
            state.layerMeta.crust = {
                key: 'crust',
                label: 'V·ªè Tr√°i ƒê·∫•t',
                emoji: 'üåç',
                group: crustGroup,
                mesh: crustMesh
            };
            crustMesh.userData.layerKey = 'crust';
            state.interactiveMeshes.push(crustMesh);
            if (cloudsMesh) {
                cloudsMesh.userData.layerKey = 'crust';
                state.interactiveMeshes.push(cloudsMesh);
            }

            createStructureLabels();
            updateStructureDetailPanel(null);
        }

        function createStructureLabels() {
            if (!structureSceneObj) return;
            const state = structureSceneObj;
            const container = document.getElementById('structureLayerLabels');
            if (!container) return;
            container.innerHTML = '';
            state.labelElements = [];

            state.layers.forEach(layer => {
                const labelEl = document.createElement('div');
                labelEl.className = 'structure-layer-label';
                labelEl.innerHTML = `<span>${layer.emoji}</span>${layer.label}`;
                container.appendChild(labelEl);
                state.labelElements.push({
                    element: labelEl,
                    layer
                });
            });
        }

        function updateStructureLabels() {
            if (!structureSceneObj || !structureSceneObj.labelElements) return;
            const state = structureSceneObj;
            const width = state.renderer.domElement.clientWidth;
            const height = state.renderer.domElement.clientHeight;
            const camera = state.camera;

            state.labelElements.forEach(({ element, layer }) => {
                const worldPos = new THREE.Vector3();
                layer.group.getWorldPosition(worldPos);
                worldPos.project(camera);

                const x = (worldPos.x * 0.5 + 0.5) * width;
                const y = (-worldPos.y * 0.5 + 0.5) * height;

                element.style.left = `${x}px`;
                element.style.top = `${y}px`;

                if (state.isSplit && worldPos.z > -1 && worldPos.z < 1) {
                    element.classList.add('active');
                } else {
                    element.classList.remove('active');
                }
            });
        }

        function bindStructureUI() {
            const infoPanel = document.getElementById('structureInfoPanel');
            if (infoPanel) {
                infoPanel.classList.add('show');
            }
        }

        function bindStructureInteractions() {
            if (!structureSceneObj) return;
            const state = structureSceneObj;
            const canvas = state.renderer.domElement;

            canvas.addEventListener('pointerdown', event => {
                if (!structureSceneObj) return;
                const hud = document.querySelector('.structure-hud');
                if (hud && hud.contains(event.target)) {
                    return;
                }
                const rect = canvas.getBoundingClientRect();
                state.pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                state.pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                state.raycaster.setFromCamera(state.pointer, state.camera);

                const intersects = state.raycaster.intersectObjects(state.interactiveMeshes, true);
                if (intersects.length > 0) {
                    const target = intersects[0].object;
                    const layerKey = target.userData.layerKey;
                    if (layerKey) {
                        if (state.activeLayerKey === layerKey) {
                            resetStructureFocus();
                        } else {
                            focusStructureLayer(layerKey);
                        }
                        return;
                    }
                }

                if (state.activeLayerKey) {
                    resetStructureFocus();
                }
            });
        }

        function toggleStructureSplit() {
            if (!structureSceneObj) return;
            const state = structureSceneObj;
            state.isSplit = !state.isSplit;

            const splitBtn = document.getElementById('structureToggleBtn');
            if (splitBtn) {
                splitBtn.classList.toggle('active', state.isSplit);
            }

            state.layers.forEach(layer => {
                gsap.to(layer.group.position, {
                    x: state.isSplit ? layer.splitX : layer.homeX,
                    duration: 0.9,
                    ease: 'power3.inOut'
                });
            });

            if (state.isSplit) {
                state.controls.autoRotate = false;
                gsap.to(state.planetGroup.rotation, {
                    y: 0,
                    duration: 0.8,
                    ease: 'power3.out'
                });
                resetStructureFocus(false);
                
                // ƒêi·ªÅu ch·ªânh camera ƒë·ªÉ nh√¨n th·∫•y r√µ t·∫•t c·∫£ c√°c l·ªõp ƒë√£ t√°ch
                // T√≠nh to√°n v·ªã tr√≠ camera d·ª±a tr√™n v·ªã tr√≠ c√°c l·ªõp
                const minX = Math.min(...state.layers.map(l => l.splitX));
                const maxX = Math.max(...state.layers.map(l => l.splitX));
                const centerX = (minX + maxX) / 2;
                const totalWidth = maxX - minX + 3; // Th√™m padding
                
                // ƒêi·ªÅu ch·ªânh camera ƒë·ªÉ bao qu√°t to√†n b·ªô c√°c l·ªõp
                gsap.to(state.camera.position, {
                    x: centerX,
                    y: 1.5,
                    z: Math.max(6, totalWidth * 0.8), // Camera xa h∆°n ƒë·ªÉ th·∫•y r√µ h∆°n
                    duration: 1.0,
                    ease: 'power3.out',
                    onUpdate: () => {
                        state.controls.update();
                    }
                });
                
                gsap.to(state.controls.target, {
                    x: centerX,
                    y: 0,
                    z: 0,
                    duration: 1.0,
                    ease: 'power3.out'
                });
            } else if (state.autoRotateInternal) {
                state.controls.autoRotate = true;
                
                // ƒê∆∞a camera v·ªÅ v·ªã tr√≠ ban ƒë·∫ßu
                gsap.to(state.camera.position, {
                    x: 0,
                    y: 1.5,
                    z: 4.5,
                    duration: 1.0,
                    ease: 'power3.out',
                    onUpdate: () => {
                        state.controls.update();
                    }
                });
                
                gsap.to(state.controls.target, {
                    x: 0,
                    y: 0,
                    z: 0,
                    duration: 1.0,
                    ease: 'power3.out'
                });
            }
        }

        function toggleStructureSeparation() {
            toggleStructureSplit();
        }

        function toggleStructureAutoRotate() {
            if (!structureSceneObj) return;
            const state = structureSceneObj;
            const btn = document.getElementById('structureRotateBtn');
            const next = !state.controls.autoRotate;
            state.controls.autoRotate = next;
            state.autoRotateInternal = next;
            if (btn) {
                btn.classList.toggle('active', next);
            }
        }

        function resetStructureView() {
            resetStructureCamera();
            resetStructureFocus();
        }

        function resetStructureCamera() {
            if (!structureSceneObj) return;
            const state = structureSceneObj;
            gsap.to(state.camera.position, {
                x: 0,
                y: 1.5,
                z: 4.5,
                duration: 0.8,
                ease: 'power3.out',
                onUpdate: () => {
                    state.controls.update();
                }
            });
            state.controls.target.set(0, 0, 0);
        }

        function focusStructureLayer(layerKey) {
            if (!structureSceneObj) return;
            const state = structureSceneObj;
            const meta = state.layerMeta[layerKey];
            if (!meta) return;

            const worldPos = new THREE.Vector3();
            meta.group.getWorldPosition(worldPos);

            const cameraOffset = new THREE.Vector3(0.7, 0.4, 0.7);
            const cameraTargetPos = worldPos.clone().add(cameraOffset);

            gsap.to(state.camera.position, {
                x: cameraTargetPos.x,
                y: cameraTargetPos.y,
                z: cameraTargetPos.z,
                duration: 1,
                ease: 'power3.out',
                onUpdate: () => {
                    state.controls.update();
                }
            });

            gsap.to(state.controls.target, {
                x: worldPos.x,
                y: worldPos.y,
                z: worldPos.z,
                duration: 0.8,
                ease: 'power3.out'
            });

            state.layers.forEach(layer => {
                const scale = layer.key === layerKey ? 1.15 : 0.95;
                gsap.to(layer.group.scale, {
                    x: scale,
                    y: scale,
                    z: scale,
                    duration: 0.6,
                    ease: 'power2.out'
                });
            });

            state.controls.autoRotate = false;
            state.activeLayerKey = layerKey;
            state.layerAutoRotateActive = true;

            updateStructureDetailPanel(layerKey);
        }

        function resetStructureFocus(animateCamera = true) {
            if (!structureSceneObj) return;
            const state = structureSceneObj;
            if (!state.activeLayerKey && animateCamera) return;

            state.layers.forEach(layer => {
                gsap.to(layer.group.scale, {
                    x: 1,
                    y: 1,
                    z: 1,
                    duration: 0.6,
                    ease: 'power2.out'
                });
            });

            if (animateCamera) {
                gsap.to(state.camera.position, {
                    x: 0,
                    y: 1.5,
                    z: 4.5,
                    duration: 0.8,
                    ease: 'power3.out',
                    onUpdate: () => state.controls.update()
                });
                state.controls.target.set(0, 0, 0);
            }

            state.activeLayerKey = null;
            state.layerAutoRotateActive = false;
            updateStructureDetailPanel(null);
        }

        function updateStructureDetailPanel(layerKey) {
            const panel = document.getElementById('structureDetailPanel');
            if (!panel) return;

            if (!layerKey || !STRUCTURE_LAYER_INFO[layerKey]) {
                panel.innerHTML = '<div class="detail-empty">Ch·ªçn m·ªôt l·ªõp ƒë·ªÉ xem chi ti·∫øt</div>';
                return;
            }

            const info = STRUCTURE_LAYER_INFO[layerKey];
            const statsHtml = info.stats.map(stat => `
                <div class="detail-stat-item">
                    <span class="detail-label">${stat.label}</span>
                    <span class="detail-value">${stat.value}</span>
                </div>
            `).join('');

            panel.innerHTML = `
                <h3>${info.icon} ${info.title}</h3>
                <p>${info.summary}</p>
                <div class="detail-stats">
                    ${statsHtml}
                </div>
            `;
        }

        function startStructureLoop() {
            if (!structureSceneObj) return;
            const state = structureSceneObj;

            function animate() {
                state.animationId = requestAnimationFrame(animate);

                if (state.controls.autoRotate && !state.isSplit) {
                    state.planetGroup.rotation.y += 0.002;
                }
                if (state.cloudsMesh) {
                    state.cloudsMesh.rotation.y += 0.0015;
                }

                if (state.layerAutoRotateActive) {
                    state.layers.forEach((layer, index) => {
                        layer.group.rotation.y += 0.003 + index * 0.001;
                    });
                }

                updateStructureLabels();
                state.controls.update();
                state.renderer.render(state.scene, state.camera);
            }

            animate();
        }

        function setupStructureResize() {
            if (!structureSceneObj) return;
            const state = structureSceneObj;
            state.resizeHandler = () => {
                if (!structureSceneObj) return;
                const { clientWidth, clientHeight } = state.container;
                state.camera.aspect = clientWidth / clientHeight;
                state.camera.updateProjectionMatrix();
                state.renderer.setSize(clientWidth, clientHeight);
            };
            window.addEventListener('resize', state.resizeHandler);
        }

        // ================================
        // VIDEO SECTION - RANH GI·ªöI TECTONIC
        // ================================
        const LOCAL_VIDEOS = [
            'video/ranh gi·ªõi h·ªôi t·ª•.mp4',                              // 0: Ranh Gi·ªõi H·ªôi T·ª•
            'video/m·∫£ng ƒë·∫°i d∆∞∆°ng v√† m·∫£ng l·ª•c ƒë·ªãa va nhau.mp4',       // 1: M·∫£ng ƒê·∫°i D∆∞∆°ng v√† M·∫£ng L·ª•c ƒê·ªãa Va Nhau
            'video/2 m·∫£ng ƒë·∫°i d∆∞∆°ng va nhau.mp4',                      // 2: 2 M·∫£ng ƒê·∫°i D∆∞∆°ng Va Nhau
            'video/2 m·∫£ng l·ª•c ƒë·ªãa va nhau.mp4',                        // 3: 2 M·∫£ng L·ª•c ƒê·ªãa Va Nhau
            'video/m·∫£ng ƒë·∫°i d∆∞∆°ng v√† m·∫£ng l·ª•c ƒë·ªãa tr∆∞·ª£t qua nhau.mp4' // 4: M·∫£ng ƒê·∫°i D∆∞∆°ng v√† M·∫£ng L·ª•c ƒê·ªãa Tr∆∞·ª£t Qua Nhau
        ];

        const videoModal = document.getElementById('videoModal');
        const videoPlayer = document.getElementById('videoPlayer');
        const videoCloseBtn = document.getElementById('videoCloseBtn');
        const videoFullscreenBtn = document.getElementById('videoFullscreenBtn');
        const videoCards = document.querySelectorAll('.video-card');

        function openVideoModal(videoIndex) {
            // First, clean up any previous video to prevent memory buildup
            videoPlayer.pause();
            videoPlayer.removeAttribute('src');
            videoPlayer.load(); // Clear the buffer
            
            // Now set the new video source
            videoPlayer.src = LOCAL_VIDEOS[videoIndex];
            videoPlayer.load(); // ensure new local source is attached before play
            videoPlayer.currentTime = 0;
            videoPlayer.play().catch(() => {
                // autoplay can fail on some browsers; user can press play manually
            });
            videoModal.classList.add('active');
        }




        videoPlayer.loop = true;
        videoPlayer.muted = false; // Ensure sound on after autoplay

        function closeVideoModal() {
            videoModal.classList.remove('active');
            videoPlayer.pause();
            videoPlayer.currentTime = 0;
            
            // Properly clear video source and free memory
            videoPlayer.removeAttribute('src');
            videoPlayer.load(); // This releases the video buffer and frees memory
        }

        videoCards.forEach((card, index) => {
            card.addEventListener('click', () => {
                openVideoModal(index);
            });
        });

        videoCloseBtn.addEventListener('click', closeVideoModal);

        videoModal.addEventListener('click', (e) => {
            if (e.target === videoModal) {
                closeVideoModal();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && videoModal.classList.contains('active')) {
                closeVideoModal();
            }
        });

        videoFullscreenBtn.addEventListener('click', () => {
            const videoModalContent = document.querySelector('.video-modal-content');
            if (!document.fullscreenElement) {
                if (videoModalContent.requestFullscreen) {
                    videoModalContent.requestFullscreen();
                } else if (videoModalContent.webkitRequestFullscreen) {
                    videoModalContent.webkitRequestFullscreen();
                } else if (videoModalContent.mozRequestFullScreen) {
                    videoModalContent.mozRequestFullScreen();
                } else if (videoModalContent.msRequestFullscreen) {
                    videoModalContent.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });
    </script>

    <!-- C·∫•u T·∫°o L√µi Tr√°i ƒê·∫•t - Earth Structure 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <!-- Plate Tectonics 2D - Thuy·∫øt Ki·∫øn T·∫°o M·∫£ng (2D ANIMATION - T√ÅCH ‚Üí GH√âP) -->
    <script src="plate-tectonics-2d.js?v=3.0"></script>
    
    <!-- Earth Structure module -->
    <script src="earth-structure.js"></script>
    
  
  <!-- Chatbot Widget -->
  <script src="chatbot-widget.js"></script>
</body>
</html>