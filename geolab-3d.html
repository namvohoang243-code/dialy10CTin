<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoLab 3D - Ph√≤ng Th√≠ Nghi·ªám ƒê·ªãa L√≠ ·∫¢o</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #fff;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Canvas 3D - B√™n tr√°i */
        #canvas-container {
            flex: 1;
            position: relative;
        }

        #info-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #info-overlay h3 {
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 18px;
        }

        #info-overlay p {
            margin: 5px 0;
            font-size: 14px;
            line-height: 1.6;
        }

        .highlight {
            color: #ffd54f;
            font-weight: bold;
        }

        /* B·∫£ng ƒëi·ªÅu khi·ªÉn - B√™n ph·∫£i */
        #control-panel {
            width: 380px;
            background: rgba(15, 20, 45, 0.95);
            padding: 30px;
            overflow-y: auto;
            border-left: 2px solid rgba(79, 195, 247, 0.3);
            box-shadow: -5px 0 30px rgba(0, 0, 0, 0.5);
        }

        #control-panel h1 {
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 24px;
            text-align: center;
            text-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }

        #control-panel .subtitle {
            text-align: center;
            color: #90caf9;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .control-group {
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .control-group:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(79, 195, 247, 0.4);
        }

        .control-group label {
            display: block;
            margin-bottom: 10px;
            color: #90caf9;
            font-weight: 600;
            font-size: 14px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            margin-bottom: 10px;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4fc3f7, #2196f3);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.6);
            transition: all 0.3s ease;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(79, 195, 247, 1);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4fc3f7, #2196f3);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.6);
        }

        .value-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #ffd54f;
            font-weight: bold;
            font-size: 16px;
        }

        .value-unit {
            font-size: 12px;
            color: #90caf9;
            font-weight: normal;
        }

        .season-indicator {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 213, 79, 0.1);
            border-radius: 8px;
            border-left: 4px solid #ffd54f;
        }

        .season-indicator h4 {
            color: #ffd54f;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .season-indicator p {
            color: #fff;
            font-size: 13px;
            line-height: 1.6;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-box .label {
            font-size: 11px;
            color: #90caf9;
            margin-bottom: 5px;
        }

        .stat-box .value {
            font-size: 18px;
            color: #4fc3f7;
            font-weight: bold;
        }

        .reset-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #4fc3f7, #2196f3);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(79, 195, 247, 0.3);
        }

        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(79, 195, 247, 0.5);
        }

        .reset-btn:active {
            transform: translateY(0);
        }

        /* Loading */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0e27;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(79, 195, 247, 0.2);
            border-top: 4px solid #4fc3f7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scrollbar */
        #control-panel::-webkit-scrollbar {
            width: 8px;
        }

        #control-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        #control-panel::-webkit-scrollbar-thumb {
            background: rgba(79, 195, 247, 0.5);
            border-radius: 4px;
        }

        #control-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(79, 195, 247, 0.8);
        }
    </style>
    <!-- Chatbot Widget CSS -->
    <link rel="stylesheet" href="chatbot-widget.css">
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
    </div>

    <div class="container">
        <!-- Canvas 3D -->
        <div id="canvas-container">
            <div id="info-overlay">
                <h3>üåç Th√¥ng tin m√¥ ph·ªèng</h3>
                <p><span class="highlight" id="season-name">M√πa ƒê√¥ng</span></p>
                <p>Vƒ© ƒë·ªô: <span class="highlight" id="lat-display">30¬∞ B·∫Øc</span></p>
                <p>Ng√†y d√†i: <span class="highlight" id="day-length">10h</span></p>
                <p>ƒê√™m d√†i: <span class="highlight" id="night-length">14h</span></p>
            </div>
        </div>

        <!-- B·∫£ng ƒëi·ªÅu khi·ªÉn -->
        <div id="control-panel">
            <h1>üß≠ GeoLab 3D</h1>
            <p class="subtitle">Th√≠ nghi·ªám h·ªá qu·∫£ ƒë·ªãa l√≠</p>

            <!-- ƒê·ªô nghi√™ng tr·ª•c -->
            <div class="control-group">
                <label>üåê ƒê·ªô nghi√™ng tr·ª•c Tr√°i ƒê·∫•t</label>
                <input type="range" id="axial-tilt" min="0" max="45" step="0.5" value="23.5">
                <div class="value-display">
                    <span id="tilt-value">23.5¬∞</span>
                    <span class="value-unit">(Th·ª±c t·∫ø: 23.5¬∞)</span>
                </div>
            </div>

            <!-- T·ªëc ƒë·ªô quay -->
            <div class="control-group">
                <label>‚ö° T·ªëc ƒë·ªô quay Tr√°i ƒê·∫•t</label>
                <input type="range" id="rotation-speed" min="0.1" max="3" step="0.1" value="1">
                <div class="value-display">
                    <span id="speed-value">1.0x</span>
                    <span class="value-unit">(1x = 24 gi·ªù/v√≤ng)</span>
                </div>
            </div>

            <!-- T·ªëc ƒë·ªô quay M·∫∑t TrƒÉng -->
            <div class="control-group">
                <label>üåô T·ªëc ƒë·ªô quay M·∫∑t TrƒÉng</label>
                <input type="range" id="moon-speed" min="0" max="0.05" step="0.001" value="0.01">
                <div class="value-display">
                    <span id="moon-speed-value">1.0x</span>
                    <span class="value-unit">(1x = 27.3 ng√†y/v√≤ng)</span>
                </div>
            </div>

            <!-- V·ªã tr√≠ qu·ªπ ƒë·∫°o -->
            <div class="control-group">
                <label>üîÑ V·ªã tr√≠ tr√™n qu·ªπ ƒë·∫°o (Th√°ng trong nƒÉm)</label>
                <input type="range" id="orbital-position" min="0" max="360" step="1" value="270">
                <div class="value-display">
                    <span id="position-value">270¬∞</span>
                    <span class="value-unit" id="month-display">(Th√°ng 12)</span>
                </div>
            </div>

            <!-- Vƒ© ƒë·ªô quan s√°t -->
            <div class="control-group">
                <label>üìç Vƒ© ƒë·ªô quan s√°t</label>
                <input type="range" id="latitude" min="-90" max="90" step="1" value="30">
                <div class="value-display">
                    <span id="lat-value">30¬∞</span>
                    <span class="value-unit" id="hemisphere">B·∫Øc</span>
                </div>
            </div>

            <!-- Th√¥ng tin m√πa -->
            <div class="season-indicator">
                <h4>üìä Ph√¢n t√≠ch k·∫øt qu·∫£</h4>
                <p id="season-description">T·∫°i vƒ© ƒë·ªô 30¬∞ B·∫Øc: Ng√†y d√†i 10h, ƒê√™m d√†i 14h - M√πa ƒê√¥ng (B·∫Øc b√°n c·∫ßu)</p>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="label">G√≥c chi·∫øu s√°ng</div>
                        <div class="value" id="sun-angle">36¬∞</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">C∆∞·ªùng ƒë·ªô √°nh s√°ng</div>
                        <div class="value" id="light-intensity">62%</div>
                    </div>
                </div>
            </div>

            <button class="reset-btn" id="reset-btn">üîÑ ƒê·∫∑t l·∫°i m·∫∑c ƒë·ªãnh</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Bi·∫øn to√†n c·ª•c
        let scene, camera, renderer;
        let earth, sun, orbit;
        let moon, moonOrbit;
        let earthRotationSpeed = 0.005;
        let moonOrbitSpeed = 0.01;
        let moonOrbitAngle = 0;
        let axialTilt = 23.5;
        let orbitalAngle = 270;
        let observationLatitude = 30;

        // Kh·ªüi t·∫°o Three.js
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene v·ªõi background ƒë∆°n gi·∫£n, s·∫°ch s·∫Ω
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e27);

            // Camera
            camera = new THREE.PerspectiveCamera(
                45,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 30, 50);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // √Ånh s√°ng m√¥i tr∆∞·ªùng - TƒÉng ƒë·ªô s√°ng v√† m√†u t·ª± nhi√™n h∆°n
            const ambientLight = new THREE.AmbientLight(0x606080, 0.4);
            scene.add(ambientLight);

            // M·∫∑t Tr·ªùi - V√†ng s√°ng ƒë·∫πp m·∫Øt
            const sunGeometry = new THREE.SphereGeometry(4.5, 64, 64);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xffdd00,  // V√†ng s√°ng
                emissive: 0xffdd00,
                emissiveIntensity: 0.9
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(0, 0, 0);
            scene.add(sun);

            // √Ånh s√°ng t·ª´ m·∫∑t tr·ªùi
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.copy(sun.position);
            sunLight.castShadow = true;
            scene.add(sunLight);

            // Point light cho m·∫∑t tr·ªùi
            const pointLight = new THREE.PointLight(0xffffff, 0.8, 100);
            pointLight.position.copy(sun.position);
            scene.add(pointLight);

            // Qu·ªπ ƒë·∫°o - ƒê∆°n gi·∫£n, tinh t·∫ø
            const orbitGeometry = new THREE.TorusGeometry(25, 0.1, 16, 100);
            const orbitMaterial = new THREE.MeshBasicMaterial({
                color: 0x4fc3f7,
                transparent: true,
                opacity: 0.5
            });
            orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbit.rotation.x = Math.PI / 2;
            scene.add(orbit);

            // Tr√°i ƒê·∫•t - ƒê·∫πp nh∆∞ m·ª•c Ng√†y v√† ƒê√™m v·ªõi texture th·ª±c t·∫ø
            const earthGeometry = new THREE.SphereGeometry(3, 64, 64);
            const earthMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,  // Tr·∫Øng ƒë·ªÉ texture hi·ªÉn th·ªã ƒë√∫ng m√†u
                emissive: 0x112244,
                emissiveIntensity: 0.1,
                specular: 0x333333,
                shininess: 15
            });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earth.castShadow = true;
            earth.receiveShadow = true;
            scene.add(earth);
            
            // T·∫£i texture Tr√°i ƒê·∫•t t·ª´ CDN
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/planets/earth_atmos_2048.jpg',
                function(texture) {
                    earthMaterial.map = texture;
                    earthMaterial.needsUpdate = true;
                },
                undefined,
                function(error) {
                    // Fallback n·∫øu kh√¥ng load ƒë∆∞·ª£c texture
                    earthMaterial.color = new THREE.Color(0x4a90e2);
                    console.log('S·ª≠ d·ª•ng m√†u d·ª± ph√≤ng cho Tr√°i ƒê·∫•t');
                }
            );

            // Th√™m l∆∞·ªõi kinh tuy·∫øn v√† vƒ© tuy·∫øn
            addEarthGrid();

            // Th√™m M·∫∑t TrƒÉng
            addMoon();

            // Th√™m ƒëi·ªÉm quan s√°t
            addObservationPoint();

            // Th√™m tr·ª•c Tr√°i ƒê·∫•t
            addEarthAxis();

            // Th√™m sao n·ªÅn
            addStars();

            // C·∫≠p nh·∫≠t v·ªã tr√≠ ban ƒë·∫ßu
            updateEarthPosition();

            // X·ª≠ l√Ω resize
            window.addEventListener('resize', onWindowResize);

            // ·∫®n loading
            setTimeout(() => {
                document.getElementById('loading').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 500);
            }, 1000);
        }

        function addEarthGrid() {
            // L∆∞·ªõi kinh tuy·∫øn v√† vƒ© tuy·∫øn
            const gridMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.2
            });

            // Vƒ© tuy·∫øn
            for (let lat = -90; lat <= 90; lat += 30) {
                const radius = 3 * Math.cos(lat * Math.PI / 180);
                const y = 3 * Math.sin(lat * Math.PI / 180);
                const points = [];
                for (let i = 0; i <= 64; i++) {
                    const angle = (i / 64) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        radius * Math.cos(angle),
                        y,
                        radius * Math.sin(angle)
                    ));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, gridMaterial);
                earth.add(line);
            }

            // Kinh tuy·∫øn
            for (let lon = 0; lon < 360; lon += 30) {
                const points = [];
                for (let lat = -90; lat <= 90; lat += 5) {
                    const phi = (90 - lat) * Math.PI / 180;
                    const theta = lon * Math.PI / 180;
                    points.push(new THREE.Vector3(
                        3 * Math.sin(phi) * Math.cos(theta),
                        3 * Math.cos(phi),
                        3 * Math.sin(phi) * Math.sin(theta)
                    ));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, gridMaterial);
                earth.add(line);
            }
        }

        function addMoon() {
            // Qu·ªπ ƒë·∫°o M·∫∑t TrƒÉng quanh Tr√°i ƒê·∫•t
            const moonOrbitRadius = 8; // Kho·∫£ng c√°ch t·ª´ Tr√°i ƒê·∫•t ƒë·∫øn M·∫∑t TrƒÉng
            const moonOrbitGeometry = new THREE.TorusGeometry(moonOrbitRadius, 0.05, 16, 100);
            const moonOrbitMaterial = new THREE.MeshBasicMaterial({
                color: 0xaaaaaa,
                transparent: true,
                opacity: 0.2
            });
            moonOrbit = new THREE.Mesh(moonOrbitGeometry, moonOrbitMaterial);
            moonOrbit.rotation.x = Math.PI / 2;

            // T·∫°o group ƒë·ªÉ qu·ªπ ƒë·∫°o di chuy·ªÉn c√πng Tr√°i ƒê·∫•t
            const moonOrbitGroup = new THREE.Group();
            moonOrbitGroup.add(moonOrbit);
            scene.add(moonOrbitGroup);

            // M·∫∑t TrƒÉng - ƒê∆°n gi·∫£n, s·∫°ch s·∫Ω
            const moonGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            const moonMaterial = new THREE.MeshPhongMaterial({
                color: 0xcccccc,
                emissive: 0x000000,
                specular: 0x333333,
                shininess: 5
            });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.castShadow = true;
            moon.receiveShadow = true;
            scene.add(moon);
            updateMoonPosition();
        }

        function updateMoonPosition() {
            if (!moon) return;

            // T√≠nh v·ªã tr√≠ c·ªßa m·∫∑t trƒÉng quay quanh Tr√°i ƒê·∫•t
            const moonOrbitRadius = 8;
            const angle = moonOrbitAngle;

            // V·ªã tr√≠ t∆∞∆°ng ƒë·ªëi so v·ªõi Tr√°i ƒê·∫•t
            const moonLocalX = moonOrbitRadius * Math.cos(angle);
            const moonLocalZ = moonOrbitRadius * Math.sin(angle);

            // V·ªã tr√≠ tuy·ªát ƒë·ªëi trong scene (Tr√°i ƒê·∫•t position + offset)
            moon.position.x = earth.position.x + moonLocalX;
            moon.position.y = earth.position.y;
            moon.position.z = earth.position.z + moonLocalZ;

            // C·∫≠p nh·∫≠t v·ªã tr√≠ qu·ªπ ƒë·∫°o m·∫∑t trƒÉng
            if (moonOrbit) {
                moonOrbit.position.copy(earth.position);
            }
        }

        let observationPoint;
        function addObservationPoint() {
            const pointGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            observationPoint = new THREE.Mesh(pointGeometry, pointMaterial);
            earth.add(observationPoint);
            updateObservationPoint();
        }

        function updateObservationPoint() {
            const lat = observationLatitude * Math.PI / 180;
            const lon = 0; // Lu√¥n ·ªü kinh tuy·∫øn 0 ƒë·ªÉ d·ªÖ quan s√°t
            observationPoint.position.set(
                3 * Math.cos(lat) * Math.cos(lon),
                3 * Math.sin(lat),
                3 * Math.cos(lat) * Math.sin(lon)
            );
        }

        let earthAxis;
        function addEarthAxis() {
            const axisGeometry = new THREE.CylinderGeometry(0.05, 0.05, 8, 8);
            const axisMaterial = new THREE.MeshBasicMaterial({ color: 0xffd54f });
            earthAxis = new THREE.Mesh(axisGeometry, axisMaterial);
            earthAxis.position.copy(earth.position);
            scene.add(earthAxis);
        }

        function addStars() {
            // T·∫°o field sao ƒë∆°n gi·∫£n, tinh t·∫ø
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];

            for (let i = 0; i < 2000; i++) {
                const x = (Math.random() - 0.5) * 300;
                const y = (Math.random() - 0.5) * 300;
                const z = (Math.random() - 0.5) * 300;
                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position',
                new THREE.Float32BufferAttribute(starVertices, 3)
            );

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.7,
                transparent: true,
                opacity: 0.8
            });

            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function updateEarthPosition() {
            const angle = orbitalAngle * Math.PI / 180;
            earth.position.x = 25 * Math.cos(angle);
            earth.position.z = 25 * Math.sin(angle);

            // C·∫≠p nh·∫≠t ƒë·ªô nghi√™ng tr·ª•c - Nghi√™ng theo tr·ª•c X ƒë·ªÉ ƒë√∫ng h∆∞·ªõng qu·ªπ ƒë·∫°o
            // Tr·ª•c Tr√°i ƒê·∫•t nghi√™ng 23.5¬∞ v·ªÅ ph√≠a b·∫Øc c·ª±c h∆∞·ªõng v·ªÅ Ng√¥i sao B·∫Øc C·ª±c
            earth.rotation.x = axialTilt * Math.PI / 180;

            // C·∫≠p nh·∫≠t tr·ª•c
            earthAxis.position.copy(earth.position);
            earthAxis.rotation.x = axialTilt * Math.PI / 180;

            // C·∫≠p nh·∫≠t v·ªã tr√≠ m·∫∑t trƒÉng
            updateMoonPosition();

            // C·∫≠p nh·∫≠t th√¥ng tin
            updateInformation();
        }

        function updateInformation() {
            // T√≠nh to√°n m√πa
            let season = '';
            let dayLength = 12;
            let sunAngle = 0;

            const normalizedAngle = ((orbitalAngle % 360) + 360) % 360;
            const isNorthern = observationLatitude >= 0;

            // X√°c ƒë·ªãnh m√πa (b·∫Øc b√°n c·∫ßu)
            if (normalizedAngle >= 330 || normalizedAngle < 60) {
                season = isNorthern ? 'M√πa ƒê√¥ng' : 'M√πa H√®';
                dayLength = isNorthern ? 10 : 14;
            } else if (normalizedAngle >= 60 && normalizedAngle < 150) {
                season = isNorthern ? 'M√πa Xu√¢n' : 'M√πa Thu';
                dayLength = 12;
            } else if (normalizedAngle >= 150 && normalizedAngle < 240) {
                season = isNorthern ? 'M√πa H√®' : 'M√πa ƒê√¥ng';
                dayLength = isNorthern ? 14 : 10;
            } else {
                season = isNorthern ? 'M√πa Thu' : 'M√πa Xu√¢n';
                dayLength = 12;
            }

            // ƒêi·ªÅu ch·ªânh ƒë·ªô d√†i ng√†y theo ƒë·ªô nghi√™ng tr·ª•c
            const tiltFactor = axialTilt / 23.5;
            const latFactor = Math.abs(observationLatitude) / 90;
            dayLength = 12 + (dayLength - 12) * tiltFactor * latFactor;
            dayLength = Math.max(0, Math.min(24, dayLength));

            const nightLength = 24 - dayLength;

            // G√≥c chi·∫øu s√°ng
            const seasonAngle = (normalizedAngle - 270) * Math.PI / 180;
            sunAngle = 90 - Math.abs(observationLatitude) - (axialTilt * Math.sin(seasonAngle));
            sunAngle = Math.max(0, Math.min(90, sunAngle));

            // C∆∞·ªùng ƒë·ªô √°nh s√°ng
            const intensity = Math.round((sunAngle / 90) * 100);

            // C·∫≠p nh·∫≠t UI
            document.getElementById('season-name').textContent = season;
            document.getElementById('day-length').textContent = dayLength.toFixed(1) + 'h';
            document.getElementById('night-length').textContent = nightLength.toFixed(1) + 'h';
            document.getElementById('sun-angle').textContent = sunAngle.toFixed(0) + '¬∞';
            document.getElementById('light-intensity').textContent = intensity + '%';

            const hemisphere = observationLatitude >= 0 ? 'B·∫Øc b√°n c·∫ßu' : 'Nam b√°n c·∫ßu';
            document.getElementById('season-description').textContent =
                `T·∫°i vƒ© ƒë·ªô ${Math.abs(observationLatitude)}¬∞ ${observationLatitude >= 0 ? 'B·∫Øc' : 'Nam'}: Ng√†y d√†i ${dayLength.toFixed(1)}h, ƒê√™m d√†i ${nightLength.toFixed(1)}h - ${season} (${hemisphere})`;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Quay Tr√°i ƒê·∫•t quanh tr·ª•c Y (t·ª± quay 24h)
            earth.rotation.y += earthRotationSpeed;

            // Duy tr√¨ g√≥c nghi√™ng tr·ª•c 23.5¬∞ (quan tr·ªçng!)
            // Ph·∫£i set l·∫°i m·ªói frame v√¨ rotation.y thay ƒë·ªïi
            earth.rotation.x = axialTilt * Math.PI / 180;
            earth.rotation.z = 0; // ƒê·∫£m b·∫£o kh√¥ng nghi√™ng theo tr·ª•c Z

            // C·∫≠p nh·∫≠t tr·ª•c Tr√°i ƒê·∫•t
            earthAxis.rotation.x = axialTilt * Math.PI / 180;
            earthAxis.rotation.z = 0;

            // Quay M·∫∑t TrƒÉng quanh Tr√°i ƒê·∫•t
            moonOrbitAngle += moonOrbitSpeed;
            updateMoonPosition();

            // T·ª± quay c·ªßa M·∫∑t TrƒÉng (quay ch·∫≠m)
            if (moon) {
                moon.rotation.y += earthRotationSpeed * 0.5;
            }

            // Render
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // X·ª≠ l√Ω ƒëi·ªÅu khi·ªÉn
        document.getElementById('axial-tilt').addEventListener('input', (e) => {
            axialTilt = parseFloat(e.target.value);
            document.getElementById('tilt-value').textContent = axialTilt.toFixed(1) + '¬∞';
            updateEarthPosition();
        });

        document.getElementById('rotation-speed').addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            earthRotationSpeed = 0.005 * speed;
            document.getElementById('speed-value').textContent = speed.toFixed(1) + 'x';
        });

        document.getElementById('moon-speed').addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            moonOrbitSpeed = speed;
            const displaySpeed = (speed / 0.01).toFixed(1);
            document.getElementById('moon-speed-value').textContent = displaySpeed + 'x';
        });

        document.getElementById('orbital-position').addEventListener('input', (e) => {
            orbitalAngle = parseFloat(e.target.value);
            document.getElementById('position-value').textContent = orbitalAngle.toFixed(0) + '¬∞';

            // Hi·ªÉn th·ªã th√°ng t∆∞∆°ng ·ª©ng
            const month = Math.floor(((orbitalAngle + 270) % 360) / 30) + 1;
            document.getElementById('month-display').textContent = `(Th√°ng ${month})`;

            updateEarthPosition();
        });

        document.getElementById('latitude').addEventListener('input', (e) => {
            observationLatitude = parseFloat(e.target.value);
            document.getElementById('lat-value').textContent = Math.abs(observationLatitude).toFixed(0) + '¬∞';
            document.getElementById('hemisphere').textContent = observationLatitude >= 0 ? 'B·∫Øc' : 'Nam';
            document.getElementById('lat-display').textContent =
                `${Math.abs(observationLatitude)}¬∞ ${observationLatitude >= 0 ? 'B·∫Øc' : 'Nam'}`;

            updateObservationPoint();
            updateInformation();
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            // Reset v·ªÅ gi√° tr·ªã m·∫∑c ƒë·ªãnh
            document.getElementById('axial-tilt').value = 23.5;
            document.getElementById('rotation-speed').value = 1;
            document.getElementById('moon-speed').value = 0.01;
            document.getElementById('orbital-position').value = 270;
            document.getElementById('latitude').value = 30;

            axialTilt = 23.5;
            earthRotationSpeed = 0.005;
            moonOrbitSpeed = 0.01;
            moonOrbitAngle = 0;
            orbitalAngle = 270;
            observationLatitude = 30;

            // C·∫≠p nh·∫≠t UI
            document.getElementById('tilt-value').textContent = '23.5¬∞';
            document.getElementById('speed-value').textContent = '1.0x';
            document.getElementById('moon-speed-value').textContent = '1.0x';
            document.getElementById('position-value').textContent = '270¬∞';
            document.getElementById('month-display').textContent = '(Th√°ng 12)';
            document.getElementById('lat-value').textContent = '30¬∞';
            document.getElementById('hemisphere').textContent = 'B·∫Øc';
            document.getElementById('lat-display').textContent = '30¬∞ B·∫Øc';

            updateEarthPosition();
            updateObservationPoint();
        });

        // Kh·ªüi ƒë·ªông
        init();
        animate();
    </script>

    <!-- Chatbot AI - Powered by Google Gemini -->
    

  <!-- Chatbot Widget -->
  <script src="chatbot-widget.js"></script>
</body>
</html>